var tipuesearch = {"pages":[{"title":" Libmbd ","text":"Libmbd At the moment the documentation consists of an automatically generated API reference and a miniature of a user guide in the following paragraph. All mathematical formulas used in the code are documented directly in the source code and rendered in Procedures . Installation instructions can be found in the Readme . The user-facing Fortran API of Libmbd is contained in the mbd module and consists of the mbd_input_t and mbd_calc_t derived types. A mbd_input_t object serves to set various options for the calculation and is used to initialize a mbd_calc_t object, which is then used to actually perform the MBD calculation. use mbd , only : mbd_input_t , mbd_calc_t type ( mbd_input_t ) :: inp type ( mbd_calc_t ) :: calc real ( 8 ) :: energy , gradients ( 3 , 2 ) integer :: code character ( 200 ) :: origin , msg inp % atom_types = [ 'Ar' , 'Ar' ] inp % coords = reshape ([ 0 d0 , 0 d0 , 0 d0 , 0 d0 , 0 d0 , 7.5d0 ], [ 3 , 2 ]) inp % xc = 'pbe' call calc % init ( inp ) call calc % get_exception ( code , origin , msg ) if ( code > 0 ) then print * , msg stop end if call calc % update_vdw_params_from_ratios ([ 0.98d0 , 0.98d0 ]) call calc % evaluate_vdw_method ( energy ) call calc % get_gradients ( gradients ) call calc % destroy ()","tags":"home","loc":"index.html"},{"title":"mbd.F90 – Libmbd","text":"Contents Modules mbd Source Code mbd.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. #include \"version.h\" #include \"defaults.h\" module mbd !! High-level Fortran API. use mbd_constants use mbd_damping , only : damping_t use mbd_formulas , only : scale_with_ratio use mbd_geom , only : geom_t use mbd_gradients , only : grad_request_t , grad_t use mbd_methods , only : get_mbd_energy , get_mbd_scs_energy use mbd_ts , only : get_ts_energy use mbd_utils , only : result_t , exception_t , printer_i use mbd_vdw_param , only : ts_vdw_params , tssurf_vdw_params , species_index implicit none private integer , parameter , public :: mbd_version_major = MBD_VERSION_MAJOR integer , parameter , public :: mbd_version_minor = MBD_VERSION_MINOR integer , parameter , public :: mbd_version_patch = MBD_VERSION_PATCH type , public :: mbd_input_t !! Contains user input to an MBD calculation. character ( len = 30 ) :: method = 'mbd-rsscs' !! VdW method to use to calculate energy and gradients. !! !! - `mbd-rsscs`: The MBD@rsSCS method. !! - `mbd-nl`: The MBD-NL method. !! - `ts`: The TS method. !! - `mbd`: Generic MBD method (without any screening). integer :: comm = - 1 !! MPI communicator. !! !! Only used when compiled with MPI. Leave as is to use the !! MPI_COMM_WORLD communicator. integer :: max_atoms_per_block = MAX_ATOMS_PER_BLOCK !! Number of atoms per block in a BLACS grid. integer :: log_level = MBD_LOG_LVL_INFO !! Level of printing procedure ( printer_i ), nopass , pointer :: printer => null () !! If assigned, will be used for logging logical :: calculate_forces = . true . !! Whether to calculate forces. logical :: calculate_vdw_params_gradients = . false . !! Whether to calculate gradients of energy w.r.t. vdW parameters logical :: calculate_spectrum = . false . !! Whether to keep MBD eigenvalues. logical :: do_rpa = . false . !! Whether to evalulate the MBD energy as an RPA integral over frequency. logical :: rpa_orders = . false . !! Whether to calculate individual RPA orders logical :: rpa_rescale_eigs = . false . !! Whether to rescale RPA eigenvalues as in 10.1021/acs.jctc.6b00925. integer :: n_omega_grid = N_FREQUENCY_GRID !! Number of imaginary frequency grid points. real ( dp ) :: k_grid_shift = K_GRID_SHIFT !! Off-\\Gamma shift of the k-point grid in units of !! inter-k-point distance. logical :: zero_negative_eigvals = . false . !! Whether to zero out negative eigenvalues. character ( len = 20 ) :: xc = '' !! XC functional for automatic setting of damping parameters. real ( dp ) :: ts_d = TS_DAMPING_D !! TS damping parameter d. real ( dp ) :: ts_sr = - 1 !! Custom TS damping parameter s_R. !! !! Leave as is to use a value based on the XC functional. real ( dp ) :: mbd_a = MBD_DAMPING_A !! MBD damping parameter a. real ( dp ) :: mbd_beta = - 1 !! Custom MBD damping parameter \\beta. !! !! Leave as is to use a value based on the XC functional. character ( len = 10 ) :: vdw_params_kind = 'ts' !! Which free-atom reference vdW parameters to use for scaling. !! !! - `ts`: Values from original TS method. !! - `tssurf`: Values from the TS&#94;\\text{surf} approach. character ( len = 3 ), allocatable :: atom_types (:) !! (N) Atom types used for picking free-atom reference values. real ( dp ), allocatable :: free_values (:, :) !! (N\\times3, a.u.) Custom free-atom vdW paramters to use for !! scaling. !! !! Columns contain static polarizabilities, C6 coefficients, and vdW !! radii. real ( dp ), allocatable :: coords (:, :) !! (3\\times N, a.u.) Atomic coordinates. real ( dp ), allocatable :: lattice_vectors (:, :) !! (3\\times 3, a.u.) Lattice vectors in columns, unallocated if not !! periodic. integer :: k_grid ( 3 ) = [ - 1 , - 1 , - 1 ] !! Number of k-points along reciprocal axes. character ( len = 10 ) :: parallel_mode = 'auto' !! Parallelization scheme. !! !! - `auto`: Pick based on system system size and number of k-points. !! - `kpoints`: Parallelize over k-points. !! - `atoms`: Parallelize over atom pairs. end type type , public :: mbd_calc_t !! Represents an MBD calculation. private type ( geom_t ) :: geom type ( damping_t ) :: damp real ( dp ), allocatable :: alpha_0 (:) real ( dp ), allocatable :: C6 (:) character ( len = 30 ) :: method type ( result_t ) :: results type ( grad_t ) :: dalpha_0 , dC6 , dr_vdw logical :: calculate_gradients logical :: calculate_vdw_params_gradients real ( dp ), allocatable :: free_values (:, :) character ( len = 30 ) :: vdw_params_update contains procedure :: init => mbd_calc_init procedure :: destroy => mbd_calc_destroy procedure :: switch_forces => mbd_calc_switch_forces procedure :: update_coords => mbd_calc_update_coords procedure :: update_lattice_vectors => mbd_calc_update_lattice_vectors procedure :: update_vdw_params_custom => mbd_calc_update_vdw_params_custom procedure :: update_vdw_params_from_ratios => mbd_calc_update_vdw_params_from_ratios procedure :: update_vdw_params_nl => mbd_calc_update_vdw_params_nl procedure :: evaluate_vdw_method => mbd_calc_evaluate_vdw_method procedure :: get_gradients => mbd_calc_get_gradients procedure :: get_vdw_params_ratios_gradients => mbd_calc_get_vdw_params_ratios_gradients procedure :: get_lattice_derivs => mbd_calc_get_lattice_derivs procedure :: get_lattice_stress => mbd_calc_get_lattice_stress procedure :: get_spectrum_modes => mbd_calc_get_spectrum_modes procedure :: get_rpa_orders => mbd_calc_get_rpa_orders procedure :: get_exception => mbd_calc_get_exception end type contains subroutine mbd_calc_init ( this , input ) !! Initialize an MBD calculation from an MBD input. class ( mbd_calc_t ), target , intent ( inout ) :: this type ( mbd_input_t ), intent ( in ) :: input !! MBD input. #ifdef WITH_MPI if ( input % comm /= - 1 ) this % geom % mpi_comm = input % comm #endif #ifdef WITH_SCALAPACK this % geom % max_atoms_per_block = input % max_atoms_per_block #endif this % method = input % method this % calculate_gradients = input % calculate_forces this % calculate_vdw_params_gradients = input % calculate_vdw_params_gradients this % geom % get_eigs = input % calculate_spectrum this % geom % get_modes = input % calculate_spectrum this % geom % do_rpa = input % do_rpa this % geom % get_rpa_orders = input % rpa_orders this % geom % param % rpa_rescale_eigs = input % rpa_rescale_eigs this % geom % param % n_freq = input % n_omega_grid this % geom % param % k_grid_shift = input % k_grid_shift this % geom % param % zero_negative_eigvals = input % zero_negative_eigvals if (. not . all ( input % k_grid == - 1 )) this % geom % k_grid = input % k_grid this % geom % coords = input % coords if ( allocated ( input % lattice_vectors )) then if ( input % method /= 'ts' . and . . not . allocated ( this % geom % k_grid )) then this % geom % exc = exception_t ( & MBD_EXC_INPUT , & 'calc%init()' , & 'Lattice vectors present but no k-grid specified' & ) return end if this % geom % lattice = input % lattice_vectors end if this % geom % parallel_mode = input % parallel_mode if ( associated ( input % printer )) this % geom % log % printer => input % printer this % geom % log % level = input % log_level call this % geom % init () if ( allocated ( input % free_values )) then this % free_values = input % free_values else select case ( input % vdw_params_kind ) case ( 'ts' ) this % free_values = ts_vdw_params (:, species_index ( input % atom_types )) case ( 'tssurf' ) this % free_values = tssurf_vdw_params (:, species_index ( input % atom_types )) end select end if if ( input % xc == '' ) then this % damp % beta = input % mbd_beta this % damp % a = input % mbd_a this % damp % ts_d = input % ts_d this % damp % ts_sr = input % ts_sr select case ( input % method ) case ( 'ts' ) if ( input % ts_sr < 0 ) then this % geom % exc % code = MBD_EXC_DAMPING this % geom % exc % msg = 'Damping parameter S_r for TS not specified' end if case default if ( input % mbd_beta < 0 ) then this % geom % exc % code = MBD_EXC_DAMPING this % geom % exc % msg = 'Damping parameter beta for MBD not specified' end if end select else this % geom % exc = this % damp % set_params_from_xc ( input % xc , input % method ) end if if ( this % geom % has_exc ()) return end subroutine subroutine mbd_calc_destroy ( this ) !! Finalize an MBD calculation. class ( mbd_calc_t ), target , intent ( inout ) :: this call this % geom % destroy () end subroutine subroutine mbd_calc_switch_forces ( this , forces ) !! Update whether to calculate forces. class ( mbd_calc_t ), intent ( inout ) :: this logical , intent ( in ) :: forces !! Whether to calcualte forces. this % calculate_gradients = forces end subroutine subroutine mbd_calc_update_coords ( this , coords ) !! Update atomic coordinates. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: coords (:, :) !! (3\\times N, a.u.) New atomic coordinates. this % geom % coords = coords end subroutine subroutine mbd_calc_update_lattice_vectors ( this , latt_vecs ) !! Update unit-cell lattice vectors. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: latt_vecs (:, :) !! (3\\times 3, a.u.) New lattice vectors in columns. this % geom % lattice = latt_vecs end subroutine subroutine mbd_calc_update_vdw_params_custom ( this , alpha_0 , C6 , r_vdw ) !! Update vdW parameters in a custom way. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: alpha_0 (:) !! (a.u.) New atomic static polarizabilities. real ( dp ), intent ( in ) :: C6 (:) !! (a.u.) New atomic C_6 coefficients. real ( dp ), intent ( in ) :: r_vdw (:) !! (a.u.) New atomic vdW radii. this % alpha_0 = alpha_0 this % C6 = C6 this % damp % r_vdw = r_vdw this % vdw_params_update = 'custom' end subroutine subroutine mbd_calc_update_vdw_params_from_ratios ( this , ratios ) !! Update vdW parameters based on scaling of free-atom values. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: ratios (:) !! Ratios of atomic volumes in the system and in vacuum. real ( dp ), allocatable :: ones (:) type ( grad_request_t ) :: grad allocate ( ones ( size ( ratios )), source = 1 d0 ) grad % dV = this % calculate_vdw_params_gradients this % alpha_0 = scale_with_ratio ( & this % free_values ( 1 , :), ratios , ones , 1 d0 , this % dalpha_0 , grad & ) this % C6 = scale_with_ratio ( & this % free_values ( 2 , :), ratios , ones , 2 d0 , this % dC6 , grad & ) this % damp % r_vdw = scale_with_ratio ( & this % free_values ( 3 , :), ratios , ones , 1 d0 / 3 , this % dr_vdw , grad & ) this % vdw_params_update = 'ratios' end subroutine subroutine mbd_calc_get_vdw_params_ratios_gradients ( this , dE_dratios ) !! Get gradients of the energy w.r.t. Hirshfeld ratios if they were !! requested in the MBD input. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( out ) :: dE_dratios (:) !! Gradients of the energy w.r.t. Hirshfeld ratios. if ( this % vdw_params_update /= 'ratios' ) return dE_dratios = ( & this % results % dE % dalpha * this % dalpha_0 % dV & + this % results % dE % dC6 * this % dC6 % dV & + this % results % dE % dr_vdw * this % dr_vdw % dV & ) end subroutine subroutine mbd_calc_update_vdw_params_nl ( this , alpha_0_ratios , C6_ratios ) !! Update vdW parameters for the MBD-NL method. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: alpha_0_ratios (:) !! Ratios of free-atom exact static polarizabilities and those from the !! VV functional. real ( dp ), intent ( in ) :: C6_ratios (:) !! Ratios of free-atom exact C_6 coefficients and those from the VV !! functional. this % alpha_0 = this % free_values ( 1 , :) * alpha_0_ratios this % C6 = this % free_values ( 2 , :) * C6_ratios this % damp % r_vdw = 2.5d0 * this % free_values ( 1 , :) ** ( 1 d0 / 7 ) * alpha_0_ratios ** ( 1 d0 / 3 ) this % vdw_params_update = 'nl' end subroutine subroutine mbd_calc_evaluate_vdw_method ( this , energy ) !! Evaluate a given vdW method for a given system and vdW parameters, !! retrieve energy. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( out ) :: energy !! (a.u.) VdW energy. type ( grad_request_t ) :: grad if ( this % calculate_gradients ) then grad % dcoords = . true . if ( allocated ( this % geom % lattice )) grad % dlattice = . true . end if if ( this % calculate_vdw_params_gradients ) then grad % dalpha = . true . grad % dC6 = . true . grad % dr_vdw = . true . end if select case ( this % method ) case ( 'mbd' , 'mbd-nl' ) this % damp % version = 'fermi,dip' this % results = get_mbd_energy ( & this % geom , this % alpha_0 , this % C6 , this % damp , grad & ) energy = this % results % energy case ( 'mbd-rsscs' ) this % results = get_mbd_scs_energy ( & this % geom , 'rsscs' , this % alpha_0 , this % C6 , this % damp , grad & ) energy = this % results % energy case ( 'ts' ) this % damp % version = 'fermi' this % results = get_ts_energy ( & this % geom , this % alpha_0 , this % C6 , this % damp , grad & ) energy = this % results % energy end select if ( this % geom % log % level <= MBD_LOG_LVL_DEBUG ) call this % geom % timer % print () end subroutine subroutine mbd_calc_get_gradients ( this , gradients ) ! 3 by N  dE/dR !! Retrieve nuclear energy gradients if they were requested in the MBD !! input. !! !! The gradients are calculated together with the energy, so a call to this !! method must be preceeded by a call to !! [[mbd_calc_t:evaluate_vdw_method]].  For the same reason, the !! gradients must be requested prior to this called via !! [[mbd_input_t:calculate_forces]]. class ( mbd_calc_t ), intent ( in ) :: this real ( dp ), intent ( out ) :: gradients (:, :) !! (3\\times N, a.u.) Energy gradients, \\mathrm dE/\\mathrm d\\mathbf !! R_i, index i runs over columns. gradients = transpose ( this % results % dE % dcoords ) end subroutine subroutine mbd_calc_get_lattice_derivs ( this , latt_derivs ) !! Provide lattice-vector energy gradients if they were requested in the MBD !! input. !! !! The gradients are actually calculated together with the energy, so a call !! to this method must be preceeded by a call to !! [[mbd_calc_t:evaluate_vdw_method]].  For the same reason, the !! gradients must be requested prior to this called via !! [[mbd_input_t:calculate_forces]]. class ( mbd_calc_t ), intent ( in ) :: this real ( dp ), intent ( out ) :: latt_derivs (:, :) !! (3\\times 3, a.u.) Energy gradients, \\mathrm dE/\\mathrm d\\mathbf !! a_i, index i runs over columns. latt_derivs = transpose ( this % results % dE % dlattice ) end subroutine subroutine mbd_calc_get_lattice_stress ( this , stress ) !! Provide stress tensor of the lattice. !! !! This is a utility function wrapping [[mbd_calc_t:get_lattice_derivs]]. !! The lattice vector gradients are coverted to the stress tensor. class ( mbd_calc_t ), intent ( in ) :: this real ( dp ), intent ( out ) :: stress (:, :) !! (3\\times 3, a.u.) Stress tensor. stress = ( & matmul ( this % geom % lattice , this % results % dE % dlattice ) & + matmul ( this % geom % coords , this % results % dE % dcoords ) & ) end subroutine subroutine mbd_calc_get_spectrum_modes ( this , spectrum , modes ) !! Provide MBD spectrum if it was requested in the MBD input. !! !! The spectrum is actually calculated together with the energy, so a call !! to this method must be preceeded by a call to !! [[mbd_calc_t:evaluate_vdw_method]].  For the same reason, the !! spectrum must be requested prior to this call via !! [[mbd_input_t:calculate_spectrum]]. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( out ) :: spectrum (:) !! (3N, a.u.) Energies (frequencies) of coupled MBD modues, !! \\omega_i. real ( dp ), intent ( out ), allocatable , optional :: modes (:, :) !! (3N\\times 3N) Coupled-mode wave functions (MBD eigenstates), !! \\psi_j, in the basis of uncoupled states, !! C_{ij}=\\langle\\phi_i|\\psi_j\\rangle, index j runs over !! columns. !! !! To save memory, the argument must be allocatable, and the method !! transfers allocation from the internal state to the argument. For !! this reason, the method can be called only once wih this optional !! argument per calculation. spectrum = this % results % mode_eigs if ( present ( modes )) call move_alloc ( this % results % modes , modes ) end subroutine subroutine mbd_calc_get_rpa_orders ( this , rpa_orders ) !! Provide RPA orders if they were requested in the MBD input. !! !! The orders are actually calculated together with the energy, so a call !! to this method must be preceeded by a call to !! [[mbd_calc_t:evaluate_vdw_method]]. For the same reason, the !! spectrum must be requested prior to this call via !! [[mbd_input_t:do_rpa]] and [[mbd_input_t:rpa_orders]]. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), allocatable , intent ( out ) :: rpa_orders (:) !! (a.u.) MBD energy decomposed to RPA orders. rpa_orders = this % results % rpa_orders end subroutine subroutine mbd_calc_get_exception ( this , code , origin , msg ) !! Retrieve an exception in the MBD calculation if it occured. class ( mbd_calc_t ), intent ( inout ) :: this integer , intent ( out ) :: code !! Exception code, values defined in [[mbd_constants]]. character ( * ), intent ( out ) :: origin !! Exception origin. character ( * ), intent ( out ) :: msg !! Exception message. code = this % geom % exc % code if ( code == 0 ) return origin = this % geom % exc % origin msg = this % geom % exc % msg this % geom % exc % code = 0 this % geom % exc % origin = '' this % geom % exc % msg = '' end subroutine end module","tags":"","loc":"sourcefile/mbd.f90.html"},{"title":"mbd_constants.f90 – Libmbd","text":"Contents Modules mbd_constants Source Code mbd_constants.f90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. module mbd_constants !! Constants used throughout. implicit none integer , parameter :: dp = kind ( 0.d0 ) real ( dp ), parameter :: pi = acos ( - 1.d0 ) real ( dp ), parameter :: ang = 1.8897259886d0 !! Value of angstrom in atomic units integer , parameter :: MBD_EXC_NEG_EIGVALS = 1 !! Negative eigenvalue exception integer , parameter :: MBD_EXC_NEG_POL = 2 !! Negative polarizability exception integer , parameter :: MBD_EXC_LINALG = 3 !! Exception in LAPACK or ScaLAPACK integer , parameter :: MBD_EXC_UNIMPL = 4 !! Functionality is not implemented integer , parameter :: MBD_EXC_DAMPING = 5 !! Damping-function exception integer , parameter :: MBD_EXC_INPUT = 6 !! Invalid input integer , parameter :: MBD_LOG_LVL_DEBUG = - 1 integer , parameter :: MBD_LOG_LVL_INFO = 0 integer , parameter :: MBD_LOG_LVL_WARN = 1 integer , parameter :: MBD_LOG_LVL_ERROR = 2 real ( dp ), parameter :: ZERO_REAL = 0 d0 complex ( dp ), parameter :: ZERO_COMPLEX = ( 0 d0 , 0 d0 ) complex ( dp ), parameter :: IMI = ( 0 d0 , 1 d0 ) end module","tags":"","loc":"sourcefile/mbd_constants.f90.html"},{"title":"mbd_gradients.f90 – Libmbd","text":"Contents Modules mbd_gradients Source Code mbd_gradients.f90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. module mbd_gradients !! Derivatives. use mbd_constants implicit none private type , public :: grad_t !! Derivatives with respect to various quantities real ( dp ), allocatable :: dcoords (:, :) ! n_atoms by 3 real ( dp ), allocatable :: dlattice (:, :) ! n_vectors by 3 real ( dp ), allocatable :: dalpha (:) real ( dp ), allocatable :: dalpha_dyn (:, :) ! n_atoms by 0:n_freq real ( dp ), allocatable :: dC6 (:) real ( dp ), allocatable :: dq (:) real ( dp ), allocatable :: dr_vdw (:) real ( dp ), allocatable :: domega (:) real ( dp ), allocatable :: dV (:) real ( dp ), allocatable :: dV_free (:) real ( dp ), allocatable :: dX_free (:) end type type , public :: grad_matrix_re_t !! Derivatives of a real dipole matrix with respect to various quantities real ( dp ), allocatable :: dr (:, :, :) real ( dp ), allocatable :: dlattice (:, :, :, :) real ( dp ), allocatable :: dvdw (:, :) real ( dp ), allocatable :: dsigma (:, :) real ( dp ), allocatable :: dgamma (:, :) end type type , public :: grad_matrix_cplx_t !! Derivatives of a compelx dipole matrix with respect to various quantities complex ( dp ), allocatable :: dr (:, :, :) complex ( dp ), allocatable :: dlattice (:, :, :, :) complex ( dp ), allocatable :: dq (:, :, :) complex ( dp ), allocatable :: dvdw (:, :) complex ( dp ), allocatable :: dsigma (:, :) complex ( dp ), allocatable :: dgamma (:, :) end type type , public :: grad_scalar_t !! Derivatives of a scalar with respect to various quantities real ( dp ), allocatable :: dr (:) real ( dp ), allocatable :: dr_1 real ( dp ), allocatable :: dk_1 real ( dp ), allocatable :: dvdw real ( dp ), allocatable :: dgamma real ( dp ), allocatable :: dC6 real ( dp ), allocatable :: dC6i real ( dp ), allocatable :: dC6j real ( dp ), allocatable :: da0i real ( dp ), allocatable :: da0j end type type , public :: grad_request_t !! Used to request derivatives with respect to function arguments logical :: dcoords = . false . logical :: dalpha = . false . logical :: dalpha_dyn = . false . logical :: dC6 = . false . logical :: dr_vdw = . false . logical :: domega = . false . logical :: dsigma = . false . logical :: dgamma = . false . logical :: dq = . false . logical :: dlattice = . false . logical :: dV = . false . logical :: dV_free = . false . logical :: dX_free = . false . contains procedure :: any => grad_request_any end type contains logical function grad_request_any ( this ) result ( any ) class ( grad_request_t ), intent ( in ) :: this any = this % dcoords & . or . this % dalpha & . or . this % dalpha_dyn & . or . this % dC6 & . or . this % dr_vdw & . or . this % domega & . or . this % dsigma & . or . this % dgamma & . or . this % dq & . or . this % dlattice & . or . this % dV & . or . this % dV_free & . or . this % dX_free end function end module","tags":"","loc":"sourcefile/mbd_gradients.f90.html"},{"title":"mbd_elsi.F90 – Libmbd","text":"Contents Modules mbd_elsi Source Code mbd_elsi.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. #ifndef DO_COMPLEX_TYPE module mbd_elsi use elsi , only : elsi_handle , elsi_init , elsi_set_mpi , elsi_set_blacs , & elsi_set_unit_ovlp , elsi_finalize , elsi_ev_real , elsi_ev_complex use mbd_constants use mbd_blacs , only : blacs_desc_t use mbd_utils , only : exception_t , is_true implicit none private public :: elsi_eigh , elsi_eigvalsh interface elsi_eigh module procedure elsi_eigh_real module procedure elsi_eigh_complex end interface interface elsi_eigvalsh module procedure elsi_eigvalsh_real module procedure elsi_eigvalsh_complex end interface contains #endif #ifndef DO_COMPLEX_TYPE subroutine elsi_eigh_real ( A , blacs_desc , eigs , exc , src , vals_only ) real ( dp ), intent ( inout ) :: A (:, :) real ( dp ), intent ( in ), optional :: src (:, :) #else subroutine elsi_eigh_complex ( A , blacs_desc , eigs , exc , src , vals_only ) complex ( dp ), intent ( inout ) :: A (:, :) complex ( dp ), intent ( in ), optional :: src (:, :) #endif type ( blacs_desc_t ), intent ( in ) :: blacs_desc real ( dp ), intent ( out ) :: eigs (:) type ( exception_t ), intent ( out ), optional :: exc logical , intent ( in ), optional :: vals_only integer :: n_vecs , n type ( elsi_handle ) :: handle #ifndef DO_COMPLEX_TYPE real ( dp ) :: DUMMY_MATRIX ( 1 , 1 ) real ( dp ), allocatable :: vecs (:, :) #else complex ( dp ) :: DUMMY_MATRIX ( 1 , 1 ) complex ( dp ), allocatable :: vecs (:, :) #endif n = 3 * blacs_desc % n_atoms if ( present ( src )) A = src if ( is_true ( vals_only )) then n_vecs = 0 else n_vecs = n end if call elsi_init ( handle , 1 , 1 , 0 , n , 0 d0 , n_vecs ) call elsi_set_mpi ( handle , blacs_desc % comm ) call elsi_set_blacs ( handle , blacs_desc % ctx , blacs_desc % blocksize ) call elsi_set_unit_ovlp ( handle , 1 ) allocate ( vecs ( size ( A , 1 ), size ( A , 2 ))) #ifndef DO_COMPLEX_TYPE call elsi_ev_real ( handle , A , DUMMY_MATRIX , eigs , vecs ) #else call elsi_ev_complex ( handle , A , DUMMY_MATRIX , eigs , vecs ) #endif A = vecs call elsi_finalize ( handle ) end subroutine #ifndef DO_COMPLEX_TYPE function elsi_eigvalsh_real ( A , blacs_desc , exc , destroy ) result ( eigs ) real ( dp ), allocatable , intent ( inout ) :: A (:, :) #else function elsi_eigvalsh_complex ( A , blacs_desc , exc , destroy ) result ( eigs ) complex ( dp ), allocatable , intent ( inout ) :: A (:, :) #endif type ( blacs_desc_t ), intent ( in ) :: blacs_desc type ( exception_t ), intent ( out ), optional :: exc logical , intent ( in ), optional :: destroy real ( dp ) :: eigs ( 3 * blacs_desc % n_atoms ) #ifndef DO_COMPLEX_TYPE real ( dp ), allocatable :: A_ (:, :) #else complex ( dp ), allocatable :: A_ (:, :) #endif if ( is_true ( destroy )) then call move_alloc ( A , A_ ) else A_ = A end if call elsi_eigh ( A_ , blacs_desc , eigs , exc , vals_only = . true .) end function #ifndef DO_COMPLEX_TYPE #   define DO_COMPLEX_TYPE #   include \"mbd_elsi.F90\" end module #endif","tags":"","loc":"sourcefile/mbd_elsi.f90.html"},{"title":"mbd_methods.F90 – Libmbd","text":"Contents Modules mbd_methods Source Code mbd_methods.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. module mbd_methods !! Obtaining MBD energies. use mbd_constants use mbd_damping , only : damping_t use mbd_formulas , only : omega_qho , alpha_dyn_qho , scale_with_ratio , C6_from_alpha use mbd_geom , only : geom_t use mbd_gradients , only : grad_t , grad_request_t use mbd_hamiltonian , only : get_mbd_hamiltonian_energy use mbd_lapack , only : eigvals , inverse use mbd_rpa , only : get_mbd_rpa_energy use mbd_scs , only : run_scs use mbd_utils , only : result_t , tostr , shift_idx #ifdef WITH_SCALAPACK use mbd_blacs , only : blacs_all_reduce #endif #ifdef WITH_MPI use mbd_mpi , only : mpi_all_reduce #endif implicit none private public :: get_mbd_energy , get_mbd_scs_energy contains type ( result_t ) function get_mbd_energy ( geom , alpha_0 , C6 , damp , grad ) result ( res ) !! Get MBD energy. !! !! For a nonperiodic system, the method just transforms C_6 coefficients !! to frequencies, and performs a single call to !! [[get_mbd_hamiltonian_energy]]. For a periodic system, the method !! integrates the energy over the frist Brillouin zone. !! !!  !! E=\\int_\\text{FBZ}\\mathrm d\\mathbf q\\,E(\\mathbf !! q)\\approx\\frac1{N_k}\\sum_i&#94;{N_k}E(\\mathbf q_i) !! \\\\ \\mathbf q_i=\\boldsymbol{\\mathcal B}\\mathbf n_i,\\qquad\\partial\\mathbf !! q_i=-\\big((\\partial\\boldsymbol{\\mathcal !! A})\\boldsymbol{\\mathcal A}&#94;{-1}\\big)&#94;\\mathrm T\\mathbf q_i !!  type ( geom_t ), intent ( inout ) :: geom real ( dp ), intent ( in ) :: alpha_0 (:) real ( dp ), intent ( in ) :: C6 (:) type ( damping_t ), intent ( in ) :: damp type ( grad_request_t ), intent ( in ) :: grad real ( dp ), allocatable :: alpha (:, :), omega (:), k_pts (:, :), dkdlattice (:, :, :, :) type ( grad_t ), allocatable :: dalpha (:) integer :: n_kpts , i_kpt , a type ( result_t ) :: res_k type ( grad_t ) :: domega type ( grad_request_t ) :: grad_ham omega = omega_qho ( C6 , alpha_0 , domega , grad ) if ( geom % do_rpa ) then alpha = alpha_dyn_qho ( alpha_0 , omega , geom % freq , dalpha , grad_request_t ()) end if grad_ham = grad if ( grad % dC6 . or . grad % dalpha ) grad_ham % domega = . true . if ( grad % dlattice ) grad_ham % dq = . true . if (. not . allocated ( geom % lattice )) then if (. not . geom % do_rpa ) then res = get_mbd_hamiltonian_energy ( geom , alpha_0 , omega , damp , grad_ham ) if ( grad % dC6 ) res % dE % dC6 = res % dE % domega * domega % dC6 if ( grad % dalpha ) res % dE % dalpha = res % dE % dalpha + res % dE % domega * domega % dalpha if ( allocated ( res % dE % domega )) deallocate ( res % dE % domega ) else res = get_mbd_rpa_energy ( geom , alpha , damp ) ! TODO gradients end if else if ( allocated ( geom % custom_k_pts )) then k_pts = geom % custom_k_pts else call make_k_pts ( & k_pts , geom % k_grid , geom % lattice , geom % param % k_grid_shift , & dkdlattice , grad % dlattice & ) end if n_kpts = size ( k_pts , 2 ) res % energy = 0 d0 if ( geom % get_eigs ) & allocate ( res % mode_eigs_k ( 3 * geom % siz (), n_kpts ), source = 0 d0 ) if ( geom % get_modes ) & allocate ( res % modes_k ( 3 * geom % siz (), 3 * geom % siz (), n_kpts ), source = ( 0 d0 , 0 d0 )) if ( geom % get_rpa_orders ) allocate ( & res % rpa_orders_k ( geom % param % rpa_order_max , n_kpts ), source = 0 d0 & ) if ( grad % dcoords ) allocate ( res % dE % dcoords ( geom % siz (), 3 ), source = 0 d0 ) if ( grad % dlattice ) allocate ( res % dE % dlattice ( 3 , 3 ), source = 0 d0 ) if ( grad % dalpha ) allocate ( res % dE % dalpha ( geom % siz ()), source = 0 d0 ) if ( grad % dC6 ) allocate ( res % dE % dC6 ( geom % siz ()), source = 0 d0 ) if ( grad % dR_vdw ) allocate ( res % dE % dR_vdw ( geom % siz ()), source = 0 d0 ) do i_kpt = 1 , n_kpts #ifdef WITH_MPI if ( geom % parallel_mode == 'k_points' ) then if ( modulo ( i_kpt , geom % mpi_size ) /= geom % mpi_rank ) cycle end if #endif call geom % clock ( 51 ) associate ( k_pt => k_pts (:, i_kpt )) if (. not . geom % do_rpa ) then res_k = get_mbd_hamiltonian_energy ( & geom , alpha_0 , omega , damp , grad_ham , k_pt & ) else res_k = get_mbd_rpa_energy ( geom , alpha , damp , k_pt ) end if end associate call geom % clock ( - 51 ) if ( geom % has_exc ()) return if ( geom % get_eigs ) then res % mode_eigs_k (:, i_kpt ) = res_k % mode_eigs end if if ( geom % get_modes ) then res % modes_k (:, :, i_kpt ) = res_k % modes_k_single end if if ( geom % get_rpa_orders ) then res % rpa_orders_k (:, i_kpt ) = res_k % rpa_orders end if res % energy = res % energy + res_k % energy / n_kpts if ( grad % dcoords ) res % dE % dcoords = res % dE % dcoords + res_k % dE % dcoords / n_kpts if ( grad % dlattice ) then res % dE % dlattice = res % dE % dlattice + res_k % dE % dlattice / n_kpts do a = 1 , 3 res % dE % dlattice = res % dE % dlattice & + res_k % dE % dq ( a ) * dkdlattice ( a , i_kpt , :, :) / n_kpts end do end if if ( grad % dalpha ) then res % dE % dalpha = res % dE % dalpha & + ( res_k % dE % dalpha + res_k % dE % domega * domega % dalpha ) / n_kpts end if if ( grad % dC6 ) res % dE % dC6 = res % dE % dC6 + res_k % dE % domega * domega % dC6 / n_kpts if ( grad % dR_vdw ) res % dE % dR_vdw = res % dE % dR_vdw + res_k % dE % dR_vdw / n_kpts end do #ifdef WITH_MPI if ( geom % parallel_mode == 'k_points' ) then call mpi_all_reduce ( res % energy , geom % mpi_comm ) if ( grad % dcoords ) call mpi_all_reduce ( res % dE % dcoords , geom % mpi_comm ) if ( grad % dlattice ) call mpi_all_reduce ( res % dE % dlattice , geom % mpi_comm ) if ( grad % dalpha ) call mpi_all_reduce ( res % dE % dalpha , geom % mpi_comm ) if ( grad % dC6 ) call mpi_all_reduce ( res % dE % dC6 , geom % mpi_comm ) if ( grad % dR_vdw ) call mpi_all_reduce ( res % dE % dR_vdw , geom % mpi_comm ) end if #endif end if end function type ( result_t ) function get_mbd_scs_energy ( geom , variant , alpha_0 , C6 , damp , grad ) result ( res ) !! Get screened MBD energy. type ( geom_t ), intent ( inout ) :: geom character ( len =* ), intent ( in ) :: variant real ( dp ), intent ( in ) :: alpha_0 (:) real ( dp ), intent ( in ) :: C6 (:) type ( damping_t ), intent ( in ) :: damp type ( grad_request_t ), intent ( in ) :: grad real ( dp ), allocatable :: alpha_dyn (:, :), alpha_dyn_scs (:, :), & dC6_scs_dalpha_dyn_scs (:, :), dene_dalpha_scs_dyn (:, :), freq_w (:), omega (:) real ( dp ) :: C6_scs ( size ( alpha_0 )) ! circumventing PGI 19 compiler bug type ( grad_t ), allocatable :: dalpha_dyn (:), dalpha_dyn_scs (:, :) type ( grad_t ) :: dE , dr_vdw_scs , domega type ( grad_request_t ) :: grad_scs type ( damping_t ) :: damp_scs , damp_mbd integer :: n_freq , i_freq , n_atoms , i_atom , my_i_atom character ( len = 15 ) :: damping_types ( 2 ) call geom % clock ( 90 ) select case ( variant ) case ( 'scs' ) damping_types = [ character ( len = 15 ) :: 'dip,gg' , 'dip,1mexp' ] case ( 'rsscs' ) damping_types = [ character ( len = 15 ) :: 'fermi,dip,gg' , 'fermi,dip' ] end select n_freq = ubound ( geom % freq , 1 ) n_atoms = geom % siz () allocate ( alpha_dyn ( n_atoms , 0 : n_freq )) allocate ( alpha_dyn_scs ( n_atoms , 0 : n_freq )) allocate ( dalpha_dyn_scs ( size ( geom % idx % i_atom ), 0 : n_freq )) if ( grad % any ()) allocate ( dene_dalpha_scs_dyn ( n_atoms , 0 : n_freq )) omega = omega_qho ( C6 , alpha_0 , domega , grad ) alpha_dyn = alpha_dyn_qho ( & alpha_0 , omega , geom % freq , dalpha_dyn , & grad_request_t ( dalpha = grad % dalpha , domega = grad % dalpha . or . grad % dC6 ) & ) grad_scs = grad_request_t ( & dcoords = grad % dcoords , & dlattice = grad % dlattice , & dalpha = grad % dalpha . or . grad % dC6 , & dr_vdw = grad % dr_vdw & ) damp_scs = damp damp_scs % version = damping_types ( 1 ) call geom % clock ( 50 ) do i_freq = 0 , n_freq alpha_dyn_scs (:, i_freq ) = run_scs ( & geom , alpha_dyn (:, i_freq ), damp_scs , dalpha_dyn_scs (:, i_freq ), grad_scs & ) if ( geom % has_exc ()) return end do call geom % clock ( - 50 ) C6_scs = C6_from_alpha ( alpha_dyn_scs , geom % freq , dC6_scs_dalpha_dyn_scs , grad % any ()) damp_mbd = damp damp_mbd % r_vdw = scale_with_ratio ( & damp % r_vdw , alpha_dyn_scs (:, 0 ), alpha_dyn (:, 0 ), 1 d0 / 3 , dr_vdw_scs , & grad_request_t ( dV = grad % any (), dV_free = grad % dalpha , dX_free = grad % dr_vdw ) & ) damp_mbd % version = damping_types ( 2 ) res = get_mbd_energy ( geom , alpha_dyn_scs (:, 0 ), C6_scs , damp_mbd , & grad_request_t ( & dcoords = grad % dcoords , dlattice = grad % dlattice , & dalpha = grad % any (), dC6 = grad % any (), dr_vdw = grad % any () & ) & ) call geom % clock ( - 90 ) if ( geom % has_exc ()) return if (. not . grad % any ()) return call geom % clock ( 91 ) allocate ( freq_w ( 0 : ubound ( geom % freq , 1 ))) freq_w = geom % freq % weight freq_w ( 0 ) = 1 d0 dene_dalpha_scs_dyn (:, 0 ) = res % dE % dalpha + res % dE % dr_vdw * dr_vdw_scs % dV do i_freq = 1 , n_freq dene_dalpha_scs_dyn (:, i_freq ) = & res % dE % dC6 * dC6_scs_dalpha_dyn_scs (:, i_freq ) end do if ( grad % dcoords ) then allocate ( dE % dcoords ( n_atoms , 3 ), source = 0 d0 ) do my_i_atom = 1 , size ( dalpha_dyn_scs , 1 ) i_atom = geom % idx % i_atom ( my_i_atom ) do i_freq = 0 , n_freq dE % dcoords ( geom % idx % j_atom , :) & = dE % dcoords ( geom % idx % j_atom , :) & + freq_w ( i_freq ) * dene_dalpha_scs_dyn ( i_atom , i_freq ) & * dalpha_dyn_scs ( my_i_atom , i_freq )% dcoords end do end do #ifdef WITH_SCALAPACK if ( geom % idx % parallel ) call blacs_all_reduce ( dE % dcoords , geom % blacs ) #endif dE % dcoords = dE % dcoords + res % dE % dcoords end if if ( grad % dlattice ) then allocate ( dE % dlattice ( 3 , 3 ), source = 0 d0 ) do my_i_atom = 1 , size ( dalpha_dyn_scs , 1 ) i_atom = geom % idx % i_atom ( my_i_atom ) if (. not . any ( i_atom == geom % idx % j_atom )) cycle do i_freq = 0 , n_freq dE % dlattice = dE % dlattice & + freq_w ( i_freq ) * dene_dalpha_scs_dyn ( i_atom , i_freq ) & * dalpha_dyn_scs ( my_i_atom , i_freq )% dlattice end do end do #ifdef WITH_SCALAPACK if ( geom % idx % parallel ) call blacs_all_reduce ( dE % dlattice , geom % blacs ) #endif dE % dlattice = dE % dlattice + res % dE % dlattice end if if ( grad % dalpha ) then allocate ( dE % dalpha ( n_atoms ), source = 0 d0 ) do my_i_atom = 1 , size ( dalpha_dyn_scs , 1 ) i_atom = geom % idx % i_atom ( my_i_atom ) do i_freq = 0 , n_freq dE % dalpha ( geom % idx % j_atom ) = dE % dalpha ( geom % idx % j_atom ) + & freq_w ( i_freq ) * dene_dalpha_scs_dyn ( i_atom , i_freq ) * & dalpha_dyn_scs ( my_i_atom , i_freq )% dalpha * ( & dalpha_dyn ( i_freq )% dalpha ( geom % idx % j_atom ) & + dalpha_dyn ( i_freq )% domega ( geom % idx % j_atom ) & * domega % dalpha ( geom % idx % j_atom ) & ) end do end do #ifdef WITH_SCALAPACK if ( geom % idx % parallel ) call blacs_all_reduce ( dE % dalpha , geom % blacs ) #endif dE % dalpha = dE % dalpha + res % dE % dr_vdw * dr_vdw_scs % dV_free end if if ( grad % dC6 ) then allocate ( dE % dC6 ( n_atoms ), source = 0 d0 ) do my_i_atom = 1 , size ( dalpha_dyn_scs , 1 ) i_atom = geom % idx % i_atom ( my_i_atom ) do i_freq = 0 , n_freq dE % dC6 ( geom % idx % j_atom ) = dE % dC6 ( geom % idx % j_atom ) + & freq_w ( i_freq ) * dene_dalpha_scs_dyn ( i_atom , i_freq ) * & dalpha_dyn_scs ( my_i_atom , i_freq )% dalpha * & dalpha_dyn ( i_freq )% domega ( geom % idx % j_atom ) & * domega % dC6 ( geom % idx % j_atom ) end do end do #ifdef WITH_SCALAPACK if ( geom % idx % parallel ) call blacs_all_reduce ( dE % dC6 , geom % blacs ) #endif end if if ( grad % dr_vdw ) then allocate ( dE % dr_vdw ( n_atoms ), source = 0 d0 ) do my_i_atom = 1 , size ( dalpha_dyn_scs , 1 ) i_atom = geom % idx % i_atom ( my_i_atom ) do i_freq = 0 , n_freq dE % dr_vdw ( geom % idx % j_atom ) = dE % dr_vdw ( geom % idx % j_atom ) + & freq_w ( i_freq ) * dene_dalpha_scs_dyn ( i_atom , i_freq ) * & dalpha_dyn_scs ( my_i_atom , i_freq )% dr_vdw end do end do #ifdef WITH_SCALAPACK if ( geom % idx % parallel ) call blacs_all_reduce ( dE % dr_vdw , geom % blacs ) #endif dE % dr_vdw = dE % dr_vdw + res % dE % dr_vdw * dr_vdw_scs % dX_free end if res % dE = dE call geom % clock ( - 91 ) end function ! This used to be a function returning the k_pts array, but that was causing ! segfaults with some compilers. I suspect some combination of the product() ! in the dimension specification and assignemnt to allocatable array. subroutine make_k_pts ( k_pts , k_grid , lattice , shift , dkdlattice , grad ) real ( dp ), allocatable , intent ( out ) :: k_pts (:, :) integer , intent ( in ) :: k_grid ( 3 ) real ( dp ), intent ( in ) :: lattice ( 3 , 3 ) real ( dp ), intent ( in ) :: shift real ( dp ), allocatable , intent ( out ) :: dkdlattice (:, :, :, :) logical , intent ( in ) :: grad integer :: n_kpt ( 3 ), i_kpt , i_latt , a , n_kpts real ( dp ) :: n_kpt_shifted ( 3 ), latt_inv ( 3 , 3 ) n_kpts = product ( k_grid ) allocate ( k_pts ( 3 , n_kpts )) n_kpt = [ 0 , 0 , - 1 ] do i_kpt = 1 , n_kpts call shift_idx ( n_kpt , [ 0 , 0 , 0 ], k_grid - 1 ) n_kpt_shifted = dble ( n_kpt ) + shift where ( 2 * n_kpt_shifted > k_grid ) n_kpt_shifted = n_kpt_shifted - dble ( k_grid ) k_pts (:, i_kpt ) = n_kpt_shifted / k_grid end do latt_inv = inverse ( lattice ) k_pts = matmul ( 2 * pi * transpose ( latt_inv ), k_pts ) if ( grad ) then allocate ( dkdlattice ( 3 , n_kpts , 3 , 3 )) do concurrent ( i_kpt = 1 : n_kpts , i_latt = 1 : 3 , a = 1 : 3 ) dkdlattice (:, i_kpt , i_latt , a ) = & - latt_inv ( i_latt , :) * k_pts ( a , i_kpt ) end do end if end subroutine end module","tags":"","loc":"sourcefile/mbd_methods.f90.html"},{"title":"mbd_ts.F90 – Libmbd","text":"Contents Modules mbd_ts Source Code mbd_ts.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. module mbd_ts !! Obtaining TS energies. use mbd_constants use mbd_utils , only : shift_idx , tostr , result_t , diff3 use mbd_damping , only : damping_t , damping_fermi use mbd_geom , only : geom_t , supercell_circum use mbd_gradients , only : grad_request_t , grad_scalar_t use mbd_lapack , only : eigvals , inverse #ifdef WITH_MPI use mbd_mpi , only : mpi_all_reduce #endif implicit none private public :: get_ts_energy contains type ( result_t ) function get_ts_energy ( geom , alpha_0 , C6 , damp , grad ) result ( res ) !! Get TS energy. type ( geom_t ), intent ( inout ) :: geom real ( dp ), intent ( in ) :: alpha_0 (:) real ( dp ), intent ( in ) :: C6 (:) type ( damping_t ), intent ( in ) :: damp type ( grad_request_t ), intent ( in ) :: grad real ( dp ) :: C6_ij , Rnij ( 3 ), Rnij_norm , R_vdw_ij , ene_ij , Rn ( 3 ), f_damp integer :: i_cell , i_atom , j_atom , range_n ( 3 ), n ( 3 ), n_atoms , i_latt logical :: is_periodic , do_ewald type ( grad_request_t ) :: grad_ij type ( grad_scalar_t ) :: df , dC6 , dphi , dene_ij do_ewald = . false . is_periodic = allocated ( geom % lattice ) n_atoms = geom % siz () grad_ij = grad grad_ij % dcoords = grad % dcoords . or . grad % dlattice if ( is_periodic ) then do_ewald = geom % gamm > 0 d0 range_n = supercell_circum ( geom % lattice , geom % real_space_cutoff ) else range_n (:) = 0 end if if ( grad % dcoords ) allocate ( res % dE % dcoords ( n_atoms , 3 ), source = 0 d0 ) if ( grad % dlattice ) allocate ( res % dE % dlattice ( 3 , 3 ), source = 0 d0 ) if ( grad % dC6 ) allocate ( res % dE % dC6 ( n_atoms ), source = 0 d0 ) if ( grad % dalpha ) allocate ( res % dE % dalpha ( n_atoms ), source = 0 d0 ) if ( grad % dr_vdw ) allocate ( res % dE % dr_vdw ( n_atoms ), source = 0 d0 ) res % energy = 0 d0 n = [ 0 , 0 , - 1 ] each_cell : do i_cell = 1 , product ( 1 + 2 * range_n ) call shift_idx ( n , - range_n , range_n ) if ( is_periodic ) then Rn = matmul ( geom % lattice , n ) else Rn (:) = 0 d0 end if each_atom : do i_atom = 1 , geom % siz () #ifdef WITH_MPI if ( modulo ( i_atom , geom % mpi_size ) /= geom % mpi_rank ) cycle #endif each_atom_pair : do j_atom = 1 , i_atom if ( i_cell == 1 ) then if ( i_atom == j_atom ) cycle end if Rnij = geom % coords (:, i_atom ) - geom % coords (:, j_atom ) - Rn Rnij_norm = sqrt ( sum ( Rnij ** 2 )) if ( is_periodic . and . Rnij_norm > geom % real_space_cutoff ) cycle C6_ij = combine_C6 ( & C6 ( i_atom ), C6 ( j_atom ), alpha_0 ( i_atom ), alpha_0 ( j_atom ), dC6 , grad & ) if ( allocated ( damp % r_vdw )) then R_vdw_ij = damp % r_vdw ( i_atom ) + damp % r_vdw ( j_atom ) end if select case ( damp % version ) case ( \"fermi\" ) f_damp = damping_fermi ( & Rnij , damp % ts_sr * R_vdw_ij , damp % ts_d , df , grad_ij & ) case ( \"fermi2\" ) f_damp = damping_fermi ( Rnij , damp % ts_sr * R_vdw_ij , damp % ts_d ) ** 2 case ( \"custom\" ) f_damp = damp % damping_custom ( i_atom , j_atom ) end select ene_ij = - C6_ij * f_damp / Rnij_norm ** 6 if ( grad_ij % dcoords ) & dene_ij % dr = ene_ij * ( df % dr / f_damp - 6 * Rnij / Rnij_norm ** 2 ) if ( grad_ij % dr_vdw ) dene_ij % dvdw = ene_ij / f_damp * df % dvdw * damp % ts_sr if ( do_ewald ) then ene_ij = ene_ij - C6_ij * ( & disp_real ( Rnij_norm , geom % gamm , dphi , grad_ij ) & - 1 d0 / Rnij_norm ** 6 & ) if ( grad_ij % dcoords ) dene_ij % dr = dene_ij % dr & - C6_ij * ( dphi % dr_1 + 6 / Rnij_norm ** 7 ) * Rnij / Rnij_norm end if if ( i_atom == j_atom ) then ene_ij = ene_ij / 2 if ( grad_ij % dcoords ) dene_ij % dr = dene_ij % dr / 2 if ( grad_ij % dr_vdw ) dene_ij % dvdw = dene_ij % dvdw / 2 end if res % energy = res % energy + ene_ij if (. not . grad % any ()) cycle if ( grad % dcoords ) then res % dE % dcoords ( i_atom , :) = res % dE % dcoords ( i_atom , :) + dene_ij % dr res % dE % dcoords ( j_atom , :) = res % dE % dcoords ( j_atom , :) - dene_ij % dr end if if ( grad % dlattice ) then do concurrent ( i_latt = 1 : 3 ) res % dE % dlattice ( i_latt , :) = res % dE % dlattice ( i_latt , :) & - dene_ij % dr * n ( i_latt ) end do end if if ( grad % dC6 ) then res % dE % dC6 ( i_atom ) = res % dE % dC6 ( i_atom ) + ene_ij / C6_ij * dC6 % dC6i res % dE % dC6 ( j_atom ) = res % dE % dC6 ( j_atom ) + ene_ij / C6_ij * dC6 % dC6j end if if ( grad % dalpha ) then res % dE % dalpha ( i_atom ) = res % dE % dalpha ( i_atom ) + ene_ij / C6_ij * dC6 % da0i res % dE % dalpha ( j_atom ) = res % dE % dalpha ( j_atom ) + ene_ij / C6_ij * dC6 % da0j end if if ( grad % dr_vdw ) then res % dE % dr_vdw ( i_atom ) = res % dE % dr_vdw ( i_atom ) + dene_ij % dvdw res % dE % dr_vdw ( j_atom ) = res % dE % dr_vdw ( j_atom ) + dene_ij % dvdw end if end do each_atom_pair end do each_atom end do each_cell if ( do_ewald ) call add_ewald_ts_parts ( geom , alpha_0 , C6 , res , grad ) #ifdef WITH_MPI call mpi_all_reduce ( res % energy , geom % mpi_comm ) if ( grad % dcoords ) call mpi_all_reduce ( res % dE % dcoords , geom % mpi_comm ) if ( grad % dlattice ) call mpi_all_reduce ( res % dE % dlattice , geom % mpi_comm ) if ( grad % dalpha ) call mpi_all_reduce ( res % dE % dalpha , geom % mpi_comm ) if ( grad % dC6 ) call mpi_all_reduce ( res % dE % dC6 , geom % mpi_comm ) if ( grad % dR_vdw ) call mpi_all_reduce ( res % dE % dR_vdw , geom % mpi_comm ) #endif end function subroutine add_ewald_ts_parts ( geom , alpha_0 , C6 , res , grad ) type ( geom_t ), intent ( in ) :: geom real ( dp ), intent ( in ) :: alpha_0 (:) real ( dp ), intent ( in ) :: C6 (:) type ( result_t ), intent ( inout ) :: res type ( grad_request_t ), intent ( in ) :: grad real ( dp ) :: rec_latt ( 3 , 3 ), volume , Rij ( 3 ), k ( 3 ), phi , dkdAk_proj , & k_norm , k_Rij , latt_inv ( 3 , 3 ), C6_ij , exp_kR , ene_ij , dkdA ( 3 ) integer :: i_atom , j_atom , m ( 3 ), i_m , range_m ( 3 ), i_latt , i_xyz type ( grad_scalar_t ) :: dC6 , dphi , dene_ij latt_inv = inverse ( geom % lattice ) rec_latt = 2 * pi * transpose ( latt_inv ) volume = abs ( dble ( product ( eigvals ( geom % lattice )))) range_m = supercell_circum ( rec_latt , geom % rec_space_cutoff ) m = [ 0 , 0 , - 1 ] each_recip_vec : do i_m = 1 , product ( 1 + 2 * range_m ) call shift_idx ( m , - range_m , range_m ) k = matmul ( rec_latt , m ) k_norm = sqrt ( sum ( k ** 2 )) if ( k_norm > geom % rec_space_cutoff ) cycle each_atom : do i_atom = 1 , geom % siz () #ifdef WITH_MPI if ( modulo ( i_atom , geom % mpi_size ) /= geom % mpi_rank ) cycle #endif each_atom_pair : do j_atom = 1 , i_atom C6_ij = combine_C6 ( & C6 ( i_atom ), C6 ( j_atom ), alpha_0 ( i_atom ), alpha_0 ( j_atom ), dC6 , grad & ) Rij = geom % coords (:, i_atom ) - geom % coords (:, j_atom ) k_Rij = dot_product ( k , Rij ) exp_kR = cos ( k_Rij ) phi = disp_rec ( k_norm , geom % gamm , dphi , grad ) ene_ij = - C6_ij * phi / volume * exp_kR if ( i_atom == j_atom ) ene_ij = ene_ij / 2 res % energy = res % energy + ene_ij if ( grad % dcoords . and . i_atom /= j_atom ) then dene_ij % dr = ene_ij / exp_kR * sin ( k_Rij ) * k res % dE % dcoords ( i_atom , :) = res % dE % dcoords ( i_atom , :) - dene_ij % dr res % dE % dcoords ( j_atom , :) = res % dE % dcoords ( j_atom , :) + dene_ij % dr end if if ( grad % dlattice ) then do concurrent ( i_latt = 1 : 3 , i_xyz = 1 : 3 ) dkdA = - latt_inv ( i_latt , :) * k ( i_xyz ) if ( k_norm > 0 d0 ) then dkdAk_proj = dot_product ( dkdA , k ) / k_norm else dkdAk_proj = 0 d0 end if res % dE % dlattice ( i_latt , i_xyz ) = res % dE % dlattice ( i_latt , i_xyz ) & - ene_ij * latt_inv ( i_latt , i_xyz ) & - ene_ij / exp_kR * sin ( k_Rij ) * dot_product ( dkdA , Rij ) & + ene_ij / phi * dphi % dk_1 * dkdAk_proj end do end if if ( grad % dC6 ) then res % dE % dC6 ( i_atom ) = res % dE % dC6 ( i_atom ) + ene_ij / C6_ij * dC6 % dC6i res % dE % dC6 ( j_atom ) = res % dE % dC6 ( j_atom ) + ene_ij / C6_ij * dC6 % dC6j end if if ( grad % dalpha ) then res % dE % dalpha ( i_atom ) = res % dE % dalpha ( i_atom ) + ene_ij / C6_ij * dC6 % da0i res % dE % dalpha ( j_atom ) = res % dE % dalpha ( j_atom ) + ene_ij / C6_ij * dC6 % da0j end if end do each_atom_pair end do each_atom end do each_recip_vec do i_atom = 1 , geom % siz () #ifdef WITH_MPI if ( modulo ( i_atom , geom % mpi_size ) /= geom % mpi_rank ) cycle #endif res % energy = res % energy + geom % gamm ** 6 / 12 * C6 ( i_atom ) ! self energy if ( grad % dC6 ) then res % dE % dC6 ( i_atom ) = res % dE % dC6 ( i_atom ) + geom % gamm ** 6 / 12 end if end do end subroutine real ( dp ) function combine_C6 ( & C6_i , C6_j , alpha_0_i , alpha_0_j , dC6 , grad ) result ( C6_ij ) real ( dp ), intent ( in ) :: C6_i , C6_j , alpha_0_i , alpha_0_j type ( grad_scalar_t ), intent ( out ) :: dC6 type ( grad_request_t ), intent ( in ) :: grad C6_ij = 2 * C6_i * C6_j & / ( alpha_0_j / alpha_0_i * C6_i + alpha_0_i / alpha_0_j * C6_j ) if ( grad % dC6 ) then dC6 % dC6i = C6_ij ** 2 * alpha_0_i / ( 2 * C6_i ** 2 * alpha_0_j ) dC6 % dC6j = C6_ij ** 2 * alpha_0_j / ( 2 * C6_j ** 2 * alpha_0_i ) end if if ( grad % dalpha ) then dC6 % da0i = C6_ij * ( 1 / alpha_0_i - C6_ij / ( C6_i * alpha_0_j )) dC6 % da0j = C6_ij * ( 1 / alpha_0_j - C6_ij / ( C6_j * alpha_0_i )) end if end function real ( dp ) function disp_real ( r , gamm , dphi , grad ) result ( phi ) real ( dp ), intent ( in ) :: r , gamm type ( grad_scalar_t ), intent ( out ) :: dphi type ( grad_request_t ), intent ( in ) :: grad real ( dp ) :: gamm_r gamm_r = gamm * r phi = ( 2 + 2 * gamm_r ** 2 + gamm_r ** 4 ) * gamm ** 6 & / ( 2 * exp ( gamm_r ** 2 ) * gamm_r ** 6 ) if ( grad % dcoords ) then dphi % dr_1 = - gamm ** 7 * ( 6 + 6 * gamm_r ** 2 + 3 * gamm_r ** 4 + gamm_r ** 6 ) & / ( exp ( gamm_r ** 2 ) * gamm_r ** 7 ) end if end function real ( dp ) function disp_rec ( k , gamm , dphi , grad ) result ( phi ) real ( dp ), intent ( in ) :: k , gamm type ( grad_scalar_t ), intent ( out ) :: dphi type ( grad_request_t ), intent ( in ) :: grad real ( dp ) :: k_gamm k_gamm = k / gamm phi = pi ** 1.5d0 * gamm ** 3 / 12 * ( & ( - 2 * ( - 2 + k_gamm ** 2 )) / exp ( k_gamm ** 2 / 4 ) & + k_gamm ** 3 * sqrt ( pi ) * erfc ( k_gamm / 2 ) & ) if ( grad % dlattice ) then dphi % dk_1 = k_gamm * pi ** 1.5d0 * gamm ** 2 / 4 * ( & - 2 / exp ( k_gamm ** 2 / 4 ) + k_gamm * sqrt ( pi ) * erfc ( k_gamm / 2 ) & ) end if end function end module","tags":"","loc":"sourcefile/mbd_ts.f90.html"},{"title":"mbd_formulas.f90 – Libmbd","text":"Contents Modules mbd_formulas Source Code mbd_formulas.f90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. module mbd_formulas !! Common formulas used at multiple places. use mbd_constants use mbd_gradients , only : grad_t , grad_request_t use mbd_utils , only : quad_pt_t , tostr implicit none private public :: omega_qho , alpha_dyn_qho , C6_from_alpha , sigma_selfint , scale_with_ratio contains function omega_qho ( C6 , alpha , domega , grad ) result ( omega ) !!  !! \\omega=\\frac{4C_6}{3\\alpha_{0}&#94;2},\\qquad !! \\partial\\omega=\\omega\\left( !! \\frac{\\partial C_6}{C_6}-\\frac{2\\partial\\alpha_0}{\\alpha_0} !! \\right) !!  real ( dp ), intent ( in ) :: C6 (:) real ( dp ), intent ( in ) :: alpha (:) type ( grad_t ), intent ( out ), optional :: domega type ( grad_request_t ), intent ( in ), optional :: grad real ( dp ) :: omega ( size ( C6 )) omega = 4 d0 / 3 * C6 / alpha ** 2 if (. not . present ( grad )) return if ( grad % dC6 ) domega % dC6 = omega / C6 if ( grad % dalpha ) domega % dalpha = - 2 * omega / alpha end function function alpha_dyn_qho ( alpha_0 , omega , freq , dalpha , grad ) result ( alpha ) !!  !! \\alpha(\\mathrm iu)=\\frac{\\alpha_0}{1+u&#94;2/\\omega&#94;2},\\qquad !! \\partial\\alpha(\\mathrm iu)=\\alpha(\\mathrm iu)\\left( !! \\frac{\\partial\\alpha_0}{\\alpha_0}+ !! \\frac2\\omega\\frac{\\partial\\omega}{1+\\omega&#94;2/u&#94;2} !! \\right) !!  real ( dp ), intent ( in ) :: alpha_0 (:) real ( dp ), intent ( in ) :: omega (:) type ( quad_pt_t ), intent ( in ) :: freq ( 0 :) type ( grad_t ), allocatable , intent ( out ) :: dalpha (:) type ( grad_request_t ), intent ( in ) :: grad real ( dp ) :: alpha ( size ( alpha_0 ), 0 : ubound ( freq , 1 )) integer :: i_freq , n_atoms n_atoms = size ( alpha_0 ) allocate ( dalpha ( 0 : ubound ( alpha , 2 ))) do i_freq = 0 , ubound ( alpha , 2 ) associate ( alpha => alpha (:, i_freq ), u => freq ( i_freq )% val ) alpha = alpha_0 / ( 1 + ( u / omega ) ** 2 ) if ( grad % dalpha ) dalpha ( i_freq )% dalpha = alpha / alpha_0 if ( grad % domega ) then if ( u <= 0 d0 ) then allocate ( dalpha ( i_freq )% domega ( size ( omega )), source = 0 d0 ) else dalpha ( i_freq )% domega = alpha * 2 d0 / omega / ( 1 d0 + ( omega / u ) ** 2 ) end if end if end associate end do end function function C6_from_alpha ( alpha , freq , dC6_dalpha , grad ) result ( C6 ) !!  !! \\bar C_6=\\frac3\\pi\\int_0&#94;\\infty\\mathrm du\\,\\bar\\alpha(u)&#94;2,\\qquad !! \\partial\\bar C_6=\\frac6\\pi\\int_0&#94;\\infty\\mathrm du !! \\bar\\alpha(u)\\partial\\bar\\alpha(u) !!  real ( dp ), intent ( in ) :: alpha (:, 0 :) type ( quad_pt_t ), intent ( in ) :: freq ( 0 :) real ( dp ), allocatable , intent ( out ), optional :: dC6_dalpha (:, :) logical , intent ( in ), optional :: grad real ( dp ) :: C6 ( size ( alpha , 1 )) integer :: i_freq , n_atoms n_atoms = size ( alpha , 1 ) C6 = 0 d0 do i_freq = 0 , ubound ( alpha , 2 ) C6 = C6 + 3 d0 / pi * alpha (:, i_freq ) ** 2 * freq ( i_freq )% weight end do if (. not . present ( grad )) return if (. not . grad ) return allocate ( dC6_dalpha ( n_atoms , 0 : ubound ( alpha , 2 )), source = 0 d0 ) do i_freq = 0 , ubound ( alpha , 2 ) dC6_dalpha (:, i_freq ) = dC6_dalpha (:, i_freq ) + 6 d0 / pi * alpha (:, i_freq ) end do end function function sigma_selfint ( alpha , dsigma_dalpha , grad ) result ( sigma ) !!  !! \\begin{gathered} !! \\sigma_i(u)=\\left(\\frac13\\sqrt{\\frac2\\pi}\\alpha_i(u)\\right)&#94;{\\frac13},\\qquad !! \\partial\\sigma_i=\\sigma_i\\frac{\\partial\\alpha_i}{3\\alpha_i} !! \\\\ \\sigma_{ij}(u)=\\sqrt{\\sigma_i(u)&#94;2+\\sigma_j(u)&#94;2},\\qquad !! \\partial\\sigma_{ij}= !! \\frac{\\sigma_i\\partial\\sigma_i+\\sigma_j\\partial\\sigma_j}{\\sigma_{ij}} !! \\end{gathered} !!  real ( dp ), intent ( in ) :: alpha (:) real ( dp ), allocatable , intent ( out ), optional :: dsigma_dalpha (:) logical , intent ( in ), optional :: grad real ( dp ) :: sigma ( size ( alpha )) sigma = ( sqrt ( 2 d0 / pi ) * alpha / 3 d0 ) ** ( 1 d0 / 3 ) if (. not . present ( grad )) return if ( grad ) dsigma_dalpha = sigma / ( 3 * alpha ) end function function scale_with_ratio ( x , yp , y , q , dx , grad ) result ( xp ) !!  !! x'=x\\left(\\frac{y'}y\\right)&#94;q,\\qquad !! \\partial x'=x\\left( !! \\frac{\\partial x}x+ !! q\\frac{\\partial y'}{y'}- !! q\\frac{\\partial y}{y} !! \\right) !!  real ( dp ), intent ( in ) :: x (:), yp (:), y (:) real ( dp ), intent ( in ) :: q type ( grad_t ), intent ( out ), optional :: dx type ( grad_request_t ), intent ( in ), optional :: grad real ( dp ) :: xp ( size ( x )) xp = x * ( yp / y ) ** q if (. not . present ( grad )) return if ( grad % dX_free ) dx % dX_free = xp / x if ( grad % dV ) dx % dV = xp * q / yp if ( grad % dV_free ) dx % dV_free = - xp * q / y end function end module","tags":"","loc":"sourcefile/mbd_formulas.f90.html"},{"title":"mbd_dipole.F90 – Libmbd","text":"Contents Modules mbd_dipole Source Code mbd_dipole.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. #ifndef DO_COMPLEX_TYPE module mbd_dipole !! Construction of dipole tensors and dipole matrices. use mbd_constants use mbd_matrix , only : matrix_re_t , matrix_cplx_t use mbd_geom , only : geom_t , supercell_circum use mbd_damping , only : damping_t , damping_fermi , damping_sqrtfermi , & op1minus_grad use mbd_gradients , only : grad_t , grad_matrix_re_t , grad_matrix_cplx_t , & grad_scalar_t , grad_request_t use mbd_lapack , only : eigvals , inverse use mbd_linalg , only : outer use mbd_utils , only : tostr , shift_idx implicit none private public :: dipole_matrix , T_bare , T_erf_coulomb , damping_grad , T_erfc , B_erfc , C_erfc interface dipole_matrix !! Form either a real or a complex dipole matrix. !! !! The real-typed version is equivalent to \\mathbf q=0. !! !!  !! \\boldsymbol{\\mathcal A}:=[\\mathbf a_1\\mathbf a_2\\mathbf !! a_3],\\qquad\\boldsymbol{\\mathcal B}:=[\\mathbf b_1\\mathbf b_2\\mathbf b_3] !! \\\\ \\boldsymbol{\\mathcal B}=2\\pi(\\boldsymbol{\\mathcal A}&#94;{-1})&#94;\\mathrm !! T,\\qquad \\partial\\boldsymbol{\\mathcal B}=-\\big((\\partial\\boldsymbol{\\mathcal !! A})\\boldsymbol{\\mathcal A}&#94;{-1}\\big)&#94;\\mathrm T\\boldsymbol{\\mathcal B} !! \\\\ \\mathbf R_\\mathbf n=\\boldsymbol{\\mathcal A}\\mathbf !! n,\\qquad\\partial\\mathbf R_\\mathbf n=(\\partial\\boldsymbol{\\mathcal !! A})\\mathbf n, !! \\\\ \\mathbf G_\\mathbf m=\\boldsymbol{\\mathcal B}\\mathbf m,\\qquad !! \\partial\\mathbf G_\\mathbf m=-\\big((\\partial\\boldsymbol{\\mathcal !! A})\\boldsymbol{\\mathcal A}&#94;{-1}\\big)&#94;\\mathrm T\\mathbf G_\\mathbf m, !! \\\\ \\frac{\\partial G_{\\mathbf ma}}{\\partial A_{bc}}=-\\mathcal A&#94;{-1}_{ca}G_{\\mathbf mb} !!  !! !!  !! \\begin{gathered} !! \\mathbf T_{ij}(\\mathbf q)=\\sum_{\\mathbf n}\\mathbf T(\\mathbf R_{\\mathbf !! nij})\\mathrm e&#94;{-\\mathrm i\\mathbf q\\cdot\\mathbf R_{\\mathbf nij}},\\quad\\mathbf !! R_{\\mathbf nij}=\\mathbf R_j+\\mathbf R_\\mathbf n-\\mathbf R_i !! \\\\ \\frac{\\mathrm d\\mathbf R_{\\mathbf nij}}{\\mathrm d\\mathbf !! R_k}=(\\delta_{jk}-\\delta_{ik})\\mathbf I !! \\\\ \\mathbf{T}_{ij}(\\mathbf{q})\\approx\\mathbf{T}&#94;\\text{Ew}_{ij}(\\mathbf{q}) !! =\\sum_\\mathbf n&#94;{|\\mathbf R_{\\mathbf nij}|<R_\\text c}\\mathbf !! T&#94;\\text{erfc}(\\mathbf R_{\\mathbf nij};\\gamma)\\mathrm e&#94;{-\\mathrm i\\mathbf !! q\\cdot\\mathbf R_{\\mathbf nij}} +\\frac{4\\pi}{V_\\text{uc}}\\sum_{\\mathbf !! m}&#94;{0<|\\mathbf k_\\mathbf m|<k_\\text c}\\mathbf{\\hat k}_\\mathbf !! m\\otimes\\mathbf{\\hat k}_\\mathbf m\\,\\mathrm e&#94;{-\\frac{k_\\mathbf !! m&#94;2}{4\\gamma&#94;2}-\\mathrm i\\mathbf G_\\mathbf m\\cdot\\mathbf R_{ij}} !! \\\\ -\\frac{4\\gamma&#94;3}{3\\sqrt\\pi}\\delta_{ij}\\mathbf I +\\delta(\\mathbf q)\\frac{4 !! \\pi}{3 V_\\text{uc}}\\mathbf I,\\qquad \\mathbf k_\\mathbf m=\\mathbf G_\\mathbf !! m+\\mathbf q !! \\end{gathered} !!  !! !! !!  !! \\partial\\left(\\frac{4\\pi}{V_\\text{uc}}\\right)=-\\frac{4\\pi}{V_\\text{uc}}\\frac{\\partial !! V_\\text{uc}}{V_\\text{uc}},\\qquad\\frac{\\partial !! V_\\text{uc}}{\\partial\\boldsymbol{\\mathcal !! A}}=V_\\text{uc}(\\boldsymbol{\\mathcal A}&#94;{-1})&#94;\\mathrm T !! \\\\ \\partial(k&#94;2)=2\\mathbf k\\cdot\\partial\\mathbf k !! \\\\ \\mathbf{\\hat k}\\otimes\\partial\\mathbf{\\hat k}=\\frac{\\mathbf !! k\\otimes\\partial\\mathbf k}{k&#94;2}-\\frac{\\mathbf k\\otimes\\mathbf !! k}{2k&#94;4}\\partial(k&#94;2) !!  !! !!  !! \\gamma:=\\frac{2.5}{\\sqrt[3]{V_\\text{uc}}},\\quad R_\\text !! c:=\\frac6\\gamma,\\quad k_\\text c:=10\\gamma !!  module procedure dipole_matrix_real module procedure dipole_matrix_complex end interface contains #endif #ifndef DO_COMPLEX_TYPE type ( matrix_re_t ) function dipole_matrix_real ( & geom , damp , ddipmat , grad ) result ( dipmat ) use mbd_constants , only : ZERO => ZERO_REAL #else type ( matrix_cplx_t ) function dipole_matrix_complex ( & geom , damp , ddipmat , grad , q ) result ( dipmat ) use mbd_constants , only : ZERO => ZERO_COMPLEX #endif type ( geom_t ), intent ( inout ) :: geom type ( damping_t ), intent ( in ) :: damp type ( grad_request_t ), intent ( in ), optional :: grad #ifndef DO_COMPLEX_TYPE type ( grad_matrix_re_t ), intent ( out ), optional :: ddipmat #else type ( grad_matrix_cplx_t ), intent ( out ), optional :: ddipmat real ( dp ), intent ( in ) :: q ( 3 ) #endif real ( dp ) :: Rn ( 3 ), Rnij ( 3 ), Rnij_norm , T ( 3 , 3 ), f_damp , & sigma_ij , T0 ( 3 , 3 ), beta_R_vdw integer :: i_atom , j_atom , i_cell , n ( 3 ), range_n ( 3 ), i , j , & n_atoms , my_i_atom , my_j_atom , i_latt , my_nr , my_nc logical :: do_ewald , is_periodic type ( grad_matrix_re_t ) :: dT , dT0 , dTew type ( grad_scalar_t ) :: df type ( grad_request_t ) :: grad_ij #ifndef DO_COMPLEX_TYPE real ( dp ) :: Tij ( 3 , 3 ) type ( grad_matrix_re_t ) :: dTij #else complex ( dp ) :: Tij ( 3 , 3 ), exp_qR type ( grad_matrix_cplx_t ) :: dTij #endif do_ewald = . false . is_periodic = allocated ( geom % lattice ) n_atoms = geom % siz () if ( present ( grad )) then grad_ij = grad grad_ij % dcoords = grad % dcoords . or . grad % dlattice end if #ifdef WITH_SCALAPACK call dipmat % init ( geom % idx , geom % blacs ) #else call dipmat % init ( geom % idx ) #endif if ( is_periodic ) then do_ewald = geom % gamm > 0 d0 range_n = supercell_circum ( geom % lattice , geom % real_space_cutoff ) else range_n (:) = 0 end if if ( grad_ij % dcoords ) allocate ( dTij % dr ( 3 , 3 , 3 )) my_nr = size ( dipmat % idx % i_atom ) my_nc = size ( dipmat % idx % j_atom ) allocate ( dipmat % val ( 3 * my_nr , 3 * my_nc ), source = ZERO ) if ( present ( grad )) then if ( grad % dcoords ) allocate ( ddipmat % dr ( 3 * my_nr , 3 * my_nc , 3 ), source = ZERO ) if ( grad % dlattice ) then allocate ( ddipmat % dlattice ( 3 * my_nr , 3 * my_nc , 3 , 3 ), source = ZERO ) end if if ( grad % dr_vdw ) then allocate ( ddipmat % dvdw ( 3 * my_nr , 3 * my_nc ), source = ZERO ) allocate ( dTij % dvdw ( 3 , 3 )) end if if ( grad % dsigma ) then allocate ( ddipmat % dsigma ( 3 * my_nr , 3 * my_nc ), source = ZERO ) allocate ( dTij % dsigma ( 3 , 3 )) end if #ifdef DO_COMPLEX_TYPE if ( grad % dq ) then allocate ( ddipmat % dq ( 3 * my_nr , 3 * my_nc , 3 ), source = ZERO ) allocate ( dTij % dq ( 3 , 3 , 3 )) end if #endif end if call geom % clock ( 11 ) n = [ 0 , 0 , - 1 ] each_cell : do i_cell = 1 , product ( 1 + 2 * range_n ) call shift_idx ( n , - range_n , range_n ) if ( is_periodic ) then Rn = matmul ( geom % lattice , n ) else Rn (:) = 0 d0 end if each_atom : do my_i_atom = 1 , size ( dipmat % idx % i_atom ) i_atom = dipmat % idx % i_atom ( my_i_atom ) each_atom_pair : do my_j_atom = 1 , size ( dipmat % idx % j_atom ) j_atom = dipmat % idx % j_atom ( my_j_atom ) if ( i_cell == 1 ) then if ( i_atom == j_atom ) cycle end if Rnij = geom % coords (:, i_atom ) - geom % coords (:, j_atom ) - Rn Rnij_norm = sqrt ( sum ( Rnij ** 2 )) if ( is_periodic . and . Rnij_norm > geom % real_space_cutoff ) cycle if ( allocated ( damp % R_vdw )) then beta_R_vdw = damp % beta * sum ( damp % R_vdw ([ i_atom , j_atom ])) end if if ( allocated ( damp % sigma )) then sigma_ij = damp % mayer_scaling & * sqrt ( sum ( damp % sigma ([ i_atom , j_atom ]) ** 2 )) end if call geom % clock ( 13 ) select case ( damp % version ) case ( \"bare\" ) T = T_bare ( Rnij , dT , grad_ij % dcoords ) case ( \"dip,1mexp\" ) T = T_1mexp_coulomb ( Rnij , beta_R_vdw , damp % a ) case ( \"fermi,dip\" ) f_damp = damping_fermi ( Rnij , beta_R_vdw , damp % a , df , grad_ij ) T0 = T_bare ( Rnij , dT0 , grad_ij % dcoords ) T = damping_grad ( f_damp , df , T0 , dT0 , dT , grad_ij ) case ( \"sqrtfermi,dip\" ) T = damping_sqrtfermi ( Rnij , beta_R_vdw , damp % a ) * T_bare ( Rnij ) case ( \"custom,dip\" ) T = damp % damping_custom ( i_atom , j_atom ) * T_bare ( Rnij ) case ( \"dip,custom\" ) T = damp % potential_custom (:, :, i_atom , j_atom ) case ( \"dip,gg\" ) T = T_erf_coulomb ( Rnij , sigma_ij , dT , grad_ij ) case ( \"fermi,dip,gg\" ) f_damp = damping_fermi ( Rnij , beta_R_vdw , damp % a , df , grad_ij ) call op1minus_grad ( f_damp , df ) T0 = T_erf_coulomb ( Rnij , sigma_ij , dT0 , grad_ij ) T = damping_grad ( f_damp , df , T0 , dT0 , dT , grad_ij ) do_ewald = . false . case ( \"sqrtfermi,dip,gg\" ) T = ( 1 d0 - damping_sqrtfermi ( Rnij , beta_R_vdw , damp % a )) * & T_erf_coulomb ( Rnij , sigma_ij ) do_ewald = . false . case ( \"custom,dip,gg\" ) T = ( 1 d0 - damp % damping_custom ( i_atom , j_atom )) * & T_erf_coulomb ( Rnij , sigma_ij ) do_ewald = . false . end select call geom % clock ( - 13 ) if ( grad_ij % dr_vdw ) dT % dvdw = damp % beta * dT % dvdw if ( do_ewald ) then T = T & + T_erfc ( Rnij , geom % gamm , dTew , grad_ij ) & - T_bare ( Rnij , dT0 , grad_ij % dcoords ) if ( grad_ij % dcoords ) dT % dr = dT % dr + dTew % dr - dT0 % dr end if Tij = T if ( grad_ij % dcoords ) dTij % dr = dT % dr if ( grad_ij % dr_vdw ) dTij % dvdw = dT % dvdw if ( grad_ij % dsigma ) dTij % dsigma = dT % dsigma #ifdef DO_COMPLEX_TYPE exp_qR = exp ( - IMI * ( dot_product ( q , Rnij ))) Tij = T * exp_qR if ( grad_ij % dcoords ) then do concurrent ( i = 1 : 3 ) dTij % dr (:, :, i ) = dT % dr (:, :, i ) * exp_qR - IMI * q ( i ) * Tij end do end if if ( grad_ij % dsigma ) dTij % dsigma = dT % dsigma * exp_qR if ( grad_ij % dr_vdw ) dTij % dvdw = dT % dvdw * exp_qR if ( grad_ij % dq ) then do concurrent ( i = 1 : 3 ) dTij % dq (:, :, i ) = - IMI * Rnij ( i ) * Tij end do end if #endif i = 3 * ( my_i_atom - 1 ) j = 3 * ( my_j_atom - 1 ) associate ( T_sub => dipmat % val ( i + 1 : i + 3 , j + 1 : j + 3 )) T_sub = T_sub + Tij end associate if (. not . present ( grad )) cycle if ( grad % dcoords . and . i_atom /= j_atom ) then associate ( dTdR_sub => ddipmat % dr ( i + 1 : i + 3 , j + 1 : j + 3 , :)) dTdR_sub = dTdR_sub + dTij % dr end associate end if if ( grad % dlattice ) then do i_latt = 1 , 3 associate ( & dTda_sub => ddipmat % dlattice ( i + 1 : i + 3 , j + 1 : j + 3 , i_latt , :) & ) dTda_sub = dTda_sub - dTij % dr * ( n ( i_latt )) end associate end do end if if ( grad % dr_vdw ) then associate ( dTdRvdw_sub => ddipmat % dvdw ( i + 1 : i + 3 , j + 1 : j + 3 )) dTdRvdw_sub = dTdRvdw_sub + dTij % dvdw end associate end if if ( grad % dsigma ) then associate ( dTdsigma_sub => ddipmat % dsigma ( i + 1 : i + 3 , j + 1 : j + 3 )) dTdsigma_sub = dTdsigma_sub + dTij % dsigma end associate end if #ifdef DO_COMPLEX_TYPE if ( grad % dq ) then associate ( dTdq_sub => ddipmat % dq ( i + 1 : i + 3 , j + 1 : j + 3 , :)) dTdq_sub = dTdq_sub + dTij % dq end associate end if #endif end do each_atom_pair end do each_atom end do each_cell call geom % clock ( - 11 ) if ( do_ewald ) then #ifndef DO_COMPLEX_TYPE call add_ewald_dipole_parts_real ( geom , dipmat , ddipmat , grad ) #else call add_ewald_dipole_parts_complex ( geom , dipmat , ddipmat , grad , q ) #endif end if end function #ifndef DO_COMPLEX_TYPE subroutine add_ewald_dipole_parts_real ( geom , dipmat , ddipmat , grad ) type ( matrix_re_t ), intent ( inout ) :: dipmat type ( grad_matrix_re_t ), intent ( inout ), optional :: ddipmat #else subroutine add_ewald_dipole_parts_complex ( geom , dipmat , ddipmat , grad , q ) type ( matrix_cplx_t ), intent ( inout ) :: dipmat type ( grad_matrix_cplx_t ), intent ( inout ), optional :: ddipmat #endif type ( geom_t ), intent ( inout ) :: geom type ( grad_request_t ), intent ( in ), optional :: grad #ifdef DO_COMPLEX_TYPE real ( dp ), intent ( in ) :: q ( 3 ) #endif logical :: do_surface real ( dp ) :: rec_latt ( 3 , 3 ), volume , G ( 3 ), Rij ( 3 ), k ( 3 ), & k_sq , G_Rij , latt_inv ( 3 , 3 ), & dGdA ( 3 ), dk_sqdA , dkk_dA ( 3 , 3 ), vol_prefactor , & k_otimes_k ( 3 , 3 ), exp_k_sq_gamma , vol_kk_exp_ksq ( 3 , 3 ) integer :: & i_atom , j_atom , i , j , i_xyz , m ( 3 ), i_m , & range_m ( 3 ), my_i_atom , my_j_atom , i_latt , a , b #ifndef DO_COMPLEX_TYPE real ( dp ) :: Tij ( 3 , 3 ), exp_GR , vol_exp #else complex ( dp ) :: Tij ( 3 , 3 ), exp_GR , vol_exp integer :: c real ( dp ) :: dkk_dq ( 3 , 3 , 3 ) #endif latt_inv = inverse ( geom % lattice ) rec_latt = 2 * pi * transpose ( latt_inv ) volume = abs ( dble ( product ( eigvals ( geom % lattice )))) vol_prefactor = 4 * pi / volume range_m = supercell_circum ( rec_latt , geom % rec_space_cutoff ) call geom % clock ( 12 ) m = [ 0 , 0 , - 1 ] each_recip_vec : do i_m = 1 , product ( 1 + 2 * range_m ) call shift_idx ( m , - range_m , range_m ) G = matmul ( rec_latt , m ) #ifdef DO_COMPLEX_TYPE k = G + q #else k = G #endif k_sq = sum ( k ** 2 ) if ( sqrt ( k_sq ) > geom % rec_space_cutoff . or . sqrt ( k_sq ) < 1 d - 15 ) cycle exp_k_sq_gamma = exp ( - k_sq / ( 4 * geom % gamm ** 2 )) do concurrent ( a = 1 : 3 , b = 1 : 3 ) k_otimes_k ( a , b ) = k ( a ) * k ( b ) / k_sq end do each_atom : do my_i_atom = 1 , size ( dipmat % idx % i_atom ) i_atom = dipmat % idx % i_atom ( my_i_atom ) each_atom_pair : do my_j_atom = 1 , size ( dipmat % idx % j_atom ) j_atom = dipmat % idx % j_atom ( my_j_atom ) Rij = geom % coords (:, i_atom ) - geom % coords (:, j_atom ) G_Rij = dot_product ( G , Rij ) #ifdef DO_COMPLEX_TYPE exp_GR = exp ( IMI * G_Rij ) #else exp_GR = cos ( G_Rij ) #endif vol_kk_exp_ksq = vol_prefactor * k_otimes_k * exp_k_sq_gamma Tij = vol_kk_exp_ksq * exp_GR i = 3 * ( my_i_atom - 1 ) j = 3 * ( my_j_atom - 1 ) associate ( T_sub => dipmat % val ( i + 1 : i + 3 , j + 1 : j + 3 )) T_sub = T_sub + Tij end associate if (. not . present ( grad )) cycle vol_exp = vol_prefactor * exp_k_sq_gamma * exp_GR if ( grad % dcoords . and . i_atom /= j_atom ) then associate ( dTdR_sub => ddipmat % dr ( i + 1 : i + 3 , j + 1 : j + 3 , :)) ! TODO should be do-concurrent, but this crashes IBM XL ! 16.1.1, see issue #16 do i_xyz = 1 , 3 dTdR_sub (:, :, i_xyz ) = dTdR_sub (:, :, i_xyz ) & #ifdef DO_COMPLEX_TYPE + Tij * IMI * G ( i_xyz ) #else - vol_kk_exp_ksq * sin ( G_Rij ) * G ( i_xyz ) #endif end do end associate end if if ( grad % dlattice ) then do i_latt = 1 , 3 do i_xyz = 1 , 3 dGdA = - latt_inv ( i_latt , :) * G ( i_xyz ) dk_sqdA = 2 * dot_product ( k , dGdA ) do concurrent ( a = 1 : 3 , b = 1 : 3 ) dkk_dA ( a , b ) = k ( a ) * dGdA ( b ) / k_sq & - k ( a ) * k ( b ) * dk_sqdA / ( 2 * k_sq ** 2 ) end do dkk_dA = dkk_dA + transpose ( dkk_dA ) ! Using associate here was causing weird seg faults ! with some Intel compilers, reporting i_xyz being ! zero in the index, even though it printed as 1 ! associate ( & !     dTda_sub => ddipmat%dlattice(i+1:i+3, j+1:j+3, i_latt, i_xyz) & ! ) ddipmat % dlattice ( i + 1 : i + 3 , j + 1 : j + 3 , i_latt , i_xyz ) = & ddipmat % dlattice ( i + 1 : i + 3 , j + 1 : j + 3 , i_latt , i_xyz ) & - Tij * latt_inv ( i_latt , i_xyz ) & + vol_exp * dkk_dA & - Tij * dk_sqdA / ( 4 * geom % gamm ** 2 ) & #ifdef DO_COMPLEX_TYPE + Tij * IMI * dot_product ( dGdA , Rij ) #else - vol_kk_exp_ksq * sin ( G_Rij ) * dot_product ( dGdA , Rij ) #endif ! end associate end do end do end if #ifdef DO_COMPLEX_TYPE if ( grad % dq ) then do concurrent ( a = 1 : 3 , b = 1 : 3 , c = 1 : 3 ) dkk_dq ( a , b , c ) = - 2 * k ( a ) * k ( b ) * k ( c ) / k_sq ** 2 end do do concurrent ( a = 1 : 3 , b = 1 : 3 ) dkk_dq ( b , a , a ) = dkk_dq ( b , a , a ) + k ( b ) / k_sq end do do concurrent ( a = 1 : 3 , b = 1 : 3 ) dkk_dq ( a , b , a ) = dkk_dq ( a , b , a ) + k ( b ) / k_sq end do associate ( dTdq_sub => ddipmat % dq ( i + 1 : i + 3 , j + 1 : j + 3 , :)) dTdq_sub = dTdq_sub + vol_exp * dkk_dq ! TODO should be do-concurrent, but this crashes IBM XL ! 16.1.1, see issue #16 do a = 1 , 3 dTdq_sub (:, :, a ) = dTdq_sub (:, :, a ) & - Tij * k ( a ) / ( 2 * geom % gamm ** 2 ) end do end associate end if #endif end do each_atom_pair end do each_atom end do each_recip_vec ! self energy call dipmat % add_diag_scalar ( - 4 * geom % gamm ** 3 / ( 3 * sqrt ( pi ))) ! surface term #ifdef DO_COMPLEX_TYPE do_surface = sqrt ( sum ( q ** 2 )) < 1 d - 15 #else do_surface = . true . #endif if ( do_surface ) then do my_i_atom = 1 , size ( dipmat % idx % i_atom ) do my_j_atom = 1 , size ( dipmat % idx % j_atom ) do i_xyz = 1 , 3 i = 3 * ( my_i_atom - 1 ) + i_xyz j = 3 * ( my_j_atom - 1 ) + i_xyz dipmat % val ( i , j ) = dipmat % val ( i , j ) + vol_prefactor / 3 if (. not . present ( grad )) cycle if ( grad % dlattice ) then ddipmat % dlattice ( i , j , :, :) = ddipmat % dlattice ( i , j , :, :) & - vol_prefactor / 3 * latt_inv end if end do end do end do end if call geom % clock ( - 12 ) end subroutine #ifndef DO_COMPLEX_TYPE #   define DO_COMPLEX_TYPE #   include \"mbd_dipole.F90\" function T_bare ( r , dT , grad ) result ( T ) !!  !! T_{ab}(\\mathbf r)=\\frac{\\partial&#94;2}{\\partial r_a\\partial r_b}\\frac1r= !! \\frac{-3r_ar_b+r&#94;2\\delta_{ab}}{r&#94;5},\\qquad !! \\frac{\\partial T_{ab}(\\mathbf r)}{\\partial r_c}=-3\\left( !! \\frac{r_a\\delta_{bc}+r_b\\delta_{ca}+r_c\\delta_{ab}}{r&#94;5}- !! \\frac{5r_ar_br_c}{r&#94;7} !! \\right) !!  real ( dp ), intent ( in ) :: r ( 3 ) type ( grad_matrix_re_t ), intent ( out ), optional :: dT logical , intent ( in ), optional :: grad real ( dp ) :: T ( 3 , 3 ) integer :: a , b , c real ( dp ) :: r_1 , r_2 , r_5 , r_7 r_2 = sum ( r ** 2 ) r_1 = sqrt ( r_2 ) r_5 = r_1 ** 5 do concurrent ( a = 1 : 3 ) T ( a , a ) = ( - 3 * r ( a ) ** 2 + r_2 ) / r_5 do concurrent ( b = a + 1 : 3 ) T ( a , b ) = - 3 * r ( a ) * r ( b ) / r_5 T ( b , a ) = T ( a , b ) end do end do if (. not . present ( grad )) return if (. not . grad ) return allocate ( dT % dr ( 3 , 3 , 3 )) r_7 = r_1 ** 7 do concurrent ( a = 1 : 3 ) dT % dr ( a , a , a ) = - 3 * ( 3 * r ( a ) / r_5 - 5 * r ( a ) ** 3 / r_7 ) do concurrent ( b = a + 1 : 3 ) dT % dr ( a , a , b ) = - 3 * ( r ( b ) / r_5 - 5 * r ( a ) ** 2 * r ( b ) / r_7 ) dT % dr ( a , b , a ) = dT % dr ( a , a , b ) dT % dr ( b , a , a ) = dT % dr ( a , a , b ) dT % dr ( b , b , a ) = - 3 * ( r ( a ) / r_5 - 5 * r ( b ) ** 2 * r ( a ) / r_7 ) dT % dr ( b , a , b ) = dT % dr ( b , b , a ) dT % dr ( a , b , b ) = dT % dr ( b , b , a ) do concurrent ( c = b + 1 : 3 ) dT % dr ( a , b , c ) = 15 * r ( a ) * r ( b ) * r ( c ) / r_7 dT % dr ( a , c , b ) = dT % dr ( a , b , c ) dT % dr ( b , a , c ) = dT % dr ( a , b , c ) dT % dr ( b , c , a ) = dT % dr ( a , b , c ) dT % dr ( c , a , b ) = dT % dr ( a , b , c ) dT % dr ( c , b , a ) = dT % dr ( a , b , c ) end do end do end do end function real ( dp ) function B_erfc ( r , gamm , dB , grad ) result ( B ) !!  !! \\begin{aligned} !! B(R,\\gamma) !! &=\\operatorname{erfc}(\\gamma R) !! +\\frac{2\\gamma R}{\\sqrt\\pi}\\mathrm e&#94;{-(\\gamma R)&#94;2} !! \\\\ \\partial B(R,\\gamma) !! &=-\\frac4{\\sqrt\\pi}(\\gamma R)&#94;2\\mathrm e&#94;{-(\\gamma R)&#94;2} !! (R\\partial\\gamma+\\gamma\\partial R) !! \\end{aligned} !!  real ( dp ), intent ( in ) :: r real ( dp ), intent ( in ) :: gamm type ( grad_scalar_t ), intent ( out ), optional :: dB type ( grad_request_t ), intent ( in ), optional :: grad real ( dp ) :: tmp , gamma_r_sq gamma_r_sq = ( gamm * r ) ** 2 B = ( erfc ( gamm * r ) + ( 2 * gamm * r / sqrt ( pi )) * exp ( - gamma_r_sq )) if (. not . present ( grad )) return tmp = - 4 d0 / sqrt ( pi ) * gamma_r_sq * exp ( - gamma_r_sq ) if ( grad % dcoords ) dB % dr_1 = tmp * gamm if ( grad % dgamma ) dB % dgamma = tmp * r end function real ( dp ) function C_erfc ( r , gamm , dC , grad ) result ( C ) !!  !! \\begin{aligned} !! C(r,\\gamma) !! &=3\\operatorname{erfc}(\\gamma R) !! +\\frac{2\\gamma R}{\\sqrt\\pi}(3+2(\\gamma R)&#94;2)\\mathrm e&#94;{-(\\gamma R)&#94;2} !! \\\\ \\partial C(R,\\gamma) !! &=-\\frac8{\\sqrt\\pi}(\\gamma R)&#94;4\\mathrm e&#94;{-(\\gamma R)&#94;2} !! (R\\partial\\gamma+\\gamma\\partial R) !! \\end{aligned} !!  real ( dp ), intent ( in ) :: r real ( dp ), intent ( in ) :: gamm type ( grad_scalar_t ), intent ( out ), optional :: dC type ( grad_request_t ), intent ( in ), optional :: grad real ( dp ) :: tmp , gamma_r_sq gamma_r_sq = ( gamm * r ) ** 2 C = ( 3 * erfc ( gamm * r ) + ( 2 * gamm * r / sqrt ( pi )) * ( 3 d0 + 2 * gamma_r_sq ) * exp ( - gamma_r_sq )) if (. not . present ( grad )) return tmp = - 8 d0 / sqrt ( pi ) * gamma_r_sq ** 2 * exp ( - gamma_r_sq ) if ( grad % dcoords ) dC % dr_1 = tmp * gamm if ( grad % dgamma ) dC % dgamma = tmp * r end function function T_erfc ( r , gamm , dT , grad ) result ( T ) !!  !! T_{ab}&#94;\\text{erfc}(\\mathbf r,\\gamma) !! =-3\\frac{r_ar_b}{r&#94;5}C(r,\\gamma)+\\frac{\\delta_{ab}}{r&#94;3}B(r,\\gamma) !!  !! !!  !! \\begin{aligned} !! \\frac{\\partial T_{ab}&#94;\\text{erfc}(\\mathbf r,\\gamma)}{\\partial r_c} !! &=-\\left( !! \\frac{r_a\\delta_{bc}+r_b\\delta_{ca}}{r&#94;5}- !! 5\\frac{r_ar_br_c}{r&#94;7} !! \\right)C(r,\\gamma)-3\\frac{r_c\\delta_{ab}}{r&#94;5}B(r,\\gamma) !! \\\\ &-\\frac{r_ar_br_c}{r&#94;6}\\frac{\\partial C(r,\\gamma)}{\\partial !! r}+\\frac{r_c\\delta_{ab}}{r&#94;4}\\frac{\\partial B(r,\\gamma)}{\\partial r} !! \\end{aligned} !!  real ( dp ), intent ( in ) :: r ( 3 ) real ( dp ), intent ( in ) :: gamm type ( grad_matrix_re_t ), intent ( out ), optional :: dT type ( grad_request_t ), intent ( in ), optional :: grad real ( dp ) :: T ( 3 , 3 ) integer :: a , b , c real ( dp ) :: r_1 , r_2 , r_3 , r_4 , r_5 , r_6 , r_7 , B_ew , C_ew type ( grad_scalar_t ) :: dB , dC r_2 = sum ( r ** 2 ) r_1 = sqrt ( r_2 ) r_3 = r_1 * r_2 r_5 = r_3 * r_2 B_ew = B_erfc ( r_1 , gamm , dB , grad ) C_ew = C_erfc ( r_1 , gamm , dC , grad ) do concurrent ( a = 1 : 3 ) T ( a , a ) = - C_ew * r ( a ) ** 2 / r_5 + B_ew / r_3 do concurrent ( b = a + 1 : 3 ) T ( a , b ) = - C_ew * r ( a ) * r ( b ) / r_5 T ( b , a ) = T ( a , b ) end do end do if (. not . present ( grad )) return if ( grad % dcoords ) then allocate ( dT % dr ( 3 , 3 , 3 )) r_7 = r_1 ** 7 r_4 = r_2 ** 2 r_6 = r_4 * r_2 do concurrent ( c = 1 : 3 ) dT % dr ( c , c , c ) = & - ( 2 * r ( c ) / r_5 - 5 * r ( c ) ** 3 / r_7 ) * C_ew - 3 * r ( c ) / r_5 * B_ew & - r ( c ) ** 3 / r_6 * dC % dr_1 + r ( c ) / r_4 * dB % dr_1 do concurrent ( a = 1 : 3 , a /= c ) dT % dr ( a , c , c ) = & - ( r ( a ) / r_5 - 5 * r ( a ) * r ( c ) ** 2 / r_7 ) * C_ew & - r ( a ) * r ( c ) ** 2 / r_6 * dC % dr_1 dT % dr ( c , a , c ) = dT % dr ( a , c , c ) dT % dr ( a , a , c ) = & 5 * r ( a ) ** 2 * r ( c ) / r_7 * C_ew - 3 * r ( c ) / r_5 * B_ew & - r ( a ) ** 2 * r ( c ) / r_6 * dC % dr_1 + r ( c ) / r_4 * dB % dr_1 do concurrent ( b = a + 1 : 3 , b /= c ) dT % dr ( a , b , c ) = & 5 * r ( a ) * r ( b ) * r ( c ) / r_7 * C_ew - r ( a ) * r ( b ) * r ( c ) / r_6 * dC % dr_1 dT % dr ( b , a , c ) = dT % dr ( a , b , c ) end do end do end do end if if ( grad % dgamma ) then allocate ( dT % dgamma ( 3 , 3 )) do concurrent ( a = 1 : 3 ) dT % dgamma ( a , a ) = - dC % dgamma * r ( a ) ** 2 / r_5 + dB % dgamma / r_3 do concurrent ( b = a + 1 : 3 ) dT % dgamma ( a , b ) = - dC % dgamma * r ( a ) * r ( b ) / r_5 dT % dgamma ( b , a ) = dT % dgamma ( a , b ) end do end do end if end function function T_erf_coulomb ( r , sigma , dT , grad ) result ( T ) !!  !! \\begin{aligned} !! T&#94;\\text{GG}_{ab}(\\mathbf r,\\sigma)&= !! \\frac{\\partial&#94;2}{\\partial r_a\\partial r_b}\\frac{\\operatorname{erf}(\\zeta)}r= !! \\big(\\operatorname{erf}(\\zeta)-\\Theta(\\zeta)\\big)T_{ab}(\\mathbf r)+ !! 2\\zeta&#94;2\\Theta(\\zeta)\\frac{r_ar_b}{r&#94;5} !! \\\\ \\Theta(\\zeta)&=\\frac{2\\zeta}{\\sqrt\\pi}\\exp(-\\zeta&#94;2),\\qquad !! \\zeta=\\frac r\\sigma !! \\\\ \\frac{\\mathrm d T_{ab}&#94;\\text{GG}(\\mathbf r,\\sigma)}{\\mathrm dr_c}&= !! 2\\zeta\\Theta(\\zeta)\\left(T_{ab}(\\mathbf r)+(3-2\\zeta&#94;2)\\frac{r_ar_b}{r&#94;5}\\right) !! \\frac{\\mathrm d\\zeta}{\\mathrm dr_c} !! \\\\ &+\\big(\\operatorname{erf}(\\zeta)-\\Theta(\\zeta)\\big) !! \\frac{\\partial T_{ab}(\\mathbf r)}{\\partial r_c}- !! 2\\zeta&#94;2\\Theta(\\zeta)\\left( !! \\frac13\\frac{\\partial T_{ab}(\\mathbf r)}{\\partial r_c}+ !! \\frac{r_c\\delta_{ab}}{r&#94;5} !! \\right) !! \\\\ \\qquad\\frac{\\mathrm d\\zeta}{\\mathrm dr_c}&= !! \\frac{r_c}{r\\sigma}-\\frac r{\\sigma&#94;2}\\frac{\\mathrm d\\sigma}{\\mathrm dr_c} !! \\end{aligned} !!  real ( dp ), intent ( in ) :: r ( 3 ) real ( dp ), intent ( in ) :: sigma type ( grad_matrix_re_t ), intent ( out ), optional :: dT type ( grad_request_t ), intent ( in ), optional :: grad real ( dp ) :: T ( 3 , 3 ) real ( dp ) :: theta , erf_theta , r_5 , r_1 , zeta , bare ( 3 , 3 ) type ( grad_matrix_re_t ) :: dbare real ( dp ) :: tmp33 ( 3 , 3 ), tmp333 ( 3 , 3 , 3 ), rr_r5 ( 3 , 3 ) integer :: a , c bare = T_bare ( r , dbare , grad % dcoords ) r_1 = sqrt ( sum ( r ** 2 )) r_5 = r_1 ** 5 rr_r5 = outer ( r , r ) / r_5 zeta = r_1 / sigma theta = 2 * zeta / sqrt ( pi ) * exp ( - zeta ** 2 ) erf_theta = erf ( zeta ) - theta T = erf_theta * bare + 2 * ( zeta ** 2 ) * theta * rr_r5 if (. not . present ( grad )) return tmp33 = 2 * zeta * theta * ( bare + ( 3 - 2 * zeta ** 2 ) * rr_r5 ) if ( grad % dcoords ) then allocate ( dT % dr ( 3 , 3 , 3 )) do concurrent ( c = 1 : 3 ) dT % dr (:, :, c ) = tmp33 * r ( c ) / ( r_1 * sigma ) end do tmp333 = dbare % dr / 3 do concurrent ( a = 1 : 3 , c = 1 : 3 ) tmp333 ( a , a , c ) = tmp333 ( a , a , c ) + r ( c ) / r_5 end do dT % dr = dT % dr + erf_theta * dbare % dr - 2 * ( zeta ** 2 ) * theta * tmp333 end if if ( grad % dsigma ) dT % dsigma = - tmp33 * r_1 / sigma ** 2 end function function T_1mexp_coulomb ( rxyz , sigma , a ) result ( T ) real ( dp ), intent ( in ) :: rxyz ( 3 ), sigma , a real ( dp ) :: T ( 3 , 3 ) real ( dp ) :: r_sigma , zeta_1 , zeta_2 r_sigma = ( sqrt ( sum ( rxyz ** 2 )) / sigma ) ** a zeta_1 = 1 d0 - exp ( - r_sigma ) - a * r_sigma * exp ( - r_sigma ) zeta_2 = - r_sigma * a * exp ( - r_sigma ) * ( 1 + a * ( - 1 + r_sigma )) T = zeta_1 * T_bare ( rxyz ) - zeta_2 * outer ( rxyz , rxyz ) / sqrt ( sum ( rxyz ** 2 )) ** 5 end function function damping_grad ( f , df , T , dT , dfT , grad ) result ( fT ) real ( dp ), intent ( in ) :: f type ( grad_scalar_t ), intent ( in ) :: df real ( dp ), intent ( in ) :: T ( 3 , 3 ) type ( grad_matrix_re_t ), intent ( in ) :: dT type ( grad_matrix_re_t ), intent ( out ) :: dfT type ( grad_request_t ), intent ( in ) :: grad real ( dp ) :: fT ( 3 , 3 ) integer :: c fT = f * T if ( grad % dcoords ) then allocate ( dfT % dr ( 3 , 3 , 3 ), source = 0 d0 ) if ( allocated ( df % dr )) then do concurrent ( c = 1 : 3 ) dfT % dr (:, :, c ) = df % dr ( c ) * T end do end if if ( allocated ( dT % dr )) dfT % dr = dfT % dr + f * dT % dr end if if ( grad % dr_vdw ) then allocate ( dfT % dvdw ( 3 , 3 ), source = 0 d0 ) if ( allocated ( df % dvdw )) dfT % dvdw = df % dvdw * T if ( allocated ( dT % dvdw )) dfT % dvdw = dfT % dvdw + f * dT % dvdw end if if ( grad % dsigma ) dfT % dsigma = f * dT % dsigma end function end module #endif","tags":"","loc":"sourcefile/mbd_dipole.f90.html"},{"title":"mbd_utils.F90 – Libmbd","text":"Contents Modules mbd_utils Source Code mbd_utils.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. module mbd_utils !! Utility types, interfaces, and procedures. use mbd_constants use mbd_gradients , only : grad_t #ifdef WITH_MPI use mbd_mpi #endif implicit none private public :: tostr , diff3 , diff5 , lower , diff7 , findval , shift_idx , & is_true , printer_i , printer integer , parameter :: i8 = selected_int_kind ( 18 ) interface tostr module procedure tostr_int module procedure tostr_real end interface interface findval module procedure findval_int end interface abstract interface subroutine printer_i ( str ) character ( len =* ), intent ( in ) :: str end subroutine end interface type , public :: logger_t integer :: level = MBD_LOG_LVL_WARN ! TODO cannot use printer() as default because of PGI 19.4 procedure ( printer_i ), nopass , pointer :: printer => null () contains procedure :: info => logger_info procedure :: debug => logger_debug procedure :: warn => logger_warn procedure :: error => logger_error end type type , public :: exception_t !! Represents an exception. integer :: code = 0 character ( 50 ) :: origin = '(unknown)' character ( 150 ) :: msg = '' end type type , public :: result_t !! Stores results from an MBD calculation real ( dp ) :: energy type ( grad_t ) :: dE real ( dp ), allocatable :: mode_eigs (:) real ( dp ), allocatable :: modes (:, :) real ( dp ), allocatable :: rpa_orders (:) real ( dp ), allocatable :: mode_eigs_k (:, :) complex ( dp ), allocatable :: modes_k (:, :, :) complex ( dp ), allocatable :: modes_k_single (:, :) real ( dp ), allocatable :: rpa_orders_k (:, :) end type type , public :: atom_index_t !! Maps from atom indexes to positions in matrices. integer , allocatable :: i_atom (:) integer , allocatable :: j_atom (:) integer :: n_atoms #   ifdef WITH_SCALAPACK logical :: parallel #   endif end type type , public :: clock_t !! Used for measuring performance. logical :: active = . true . integer ( i8 ), allocatable :: timestamps (:), counts (:) contains procedure :: init => clock_init procedure :: clock => clock_clock procedure :: print => clock_print end type type , public :: quad_pt_t !! Represents a 1D quadrature point real ( dp ) :: val real ( dp ) :: weight end type contains character ( len = 50 ) elemental function tostr_int ( k , format ) result ( s ) integer , intent ( in ) :: k character ( len =* ), intent ( in ), optional :: format if ( present ( format )) then write ( s , format ) k else write ( s , \"(i20)\" ) k end if s = adjustl ( s ) end function character ( len = 50 ) elemental function tostr_real ( x , format ) result ( s ) real ( dp ), intent ( in ) :: x character ( * ), intent ( in ), optional :: format if ( present ( format )) then write ( s , format ) x else write ( s , \"(g50.17e3)\" ) x end if s = adjustl ( s ) end function real ( dp ) pure function diff3 ( x , delta ) real ( dp ), intent ( in ) :: x ( - 1 :) real ( dp ), intent ( in ) :: delta diff3 = ( x ( 1 ) - x ( - 1 )) / ( 2 * delta ) end function real ( dp ) pure function diff5 ( x , delta ) real ( dp ), intent ( in ) :: x ( - 2 :) real ( dp ), intent ( in ) :: delta diff5 = ( 1.d0 / 12 * x ( - 2 ) - 2.d0 / 3 * x ( - 1 ) + 2.d0 / 3 * x ( 1 ) - 1.d0 / 12 * x ( 2 )) / delta end function real ( dp ) pure function diff7 ( x , delta ) real ( dp ), intent ( in ) :: x ( - 3 :) real ( dp ), intent ( in ) :: delta diff7 = ( & - 1.d0 / 60 * x ( - 3 ) & + 3.d0 / 20 * x ( - 2 ) & - 3.d0 / 4 * x ( - 1 ) & + 3.d0 / 4 * x ( 1 ) & - 3.d0 / 20 * x ( 2 ) & + 1.d0 / 60 * x ( 3 ) & ) / delta end function pure function lower ( str ) character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: lower integer :: i do i = 1 , len ( str ) select case ( str ( i : i )) case ( 'A' : 'Z' ) lower ( i : i ) = achar ( iachar ( str ( i : i )) + 32 ) case default lower ( i : i ) = str ( i : i ) end select end do end function integer pure function findval_int ( array , val ) result ( idx ) integer , intent ( in ) :: array (:), val integer :: i idx = 0 do i = 1 , size ( array ) if ( val == array ( i )) then idx = i return end if end do end function subroutine shift_idx ( idx , start , finish ) integer , intent ( inout ) :: idx (:) integer , intent ( in ) :: start (:), finish (:) integer :: i_dim , i do i_dim = size ( idx ), 1 , - 1 i = idx ( i_dim ) + 1 if ( i <= finish ( i_dim )) then idx ( i_dim ) = i return else idx ( i_dim ) = start ( i_dim ) end if end do end subroutine subroutine clock_init ( this , n ) class ( clock_t ), intent ( inout ) :: this integer , intent ( in ) :: n allocate ( this % timestamps ( n ), source = 0_i8 ) allocate ( this % counts ( n ), source = 0_i8 ) end subroutine subroutine clock_clock ( this , id ) class ( clock_t ), intent ( inout ) :: this integer , intent ( in ) :: id integer ( i8 ) :: cnt , rate , cnt_max integer :: absid if (. not . this % active ) return call system_clock ( cnt , rate , cnt_max ) if ( id > 0 ) then this % timestamps ( id ) = this % timestamps ( id ) - cnt else absid = abs ( id ) this % timestamps ( absid ) = this % timestamps ( absid ) + cnt this % counts ( absid ) = this % counts ( absid ) + 1 end if end subroutine subroutine clock_print ( this ) class ( clock_t ), intent ( inout ) :: this integer ( i8 ) :: cnt , rate , cnt_max integer :: i character ( len = 20 ) :: label #ifdef WITH_MPI if ( mpi_get_rank () /= 0 ) return #endif call system_clock ( cnt , rate , cnt_max ) print '(A20,A10,A10)' , 'id' , 'count' , 'time (s)' do i = 1 , size ( this % counts ) if ( this % counts ( i ) == 0 ) cycle select case ( i ) case ( 11 ); label = 'dipole real space' case ( 12 ); label = 'dipole rec space' case ( 13 ); label = 'dipole real 3x3' case ( 21 ); label = 'eig MBD' case ( 23 ); label = 'eig RPA' case ( 24 ); label = 'eig RPA orders' case ( 25 ); label = 'MBD forces' case ( 32 ); label = 'inv SCS' case ( 50 ); label = 'SCS' case ( 51 ); label = 'single k-point' case ( 90 ); label = 'MBD@rsSCS' case ( 91 ); label = 'MBD@rsSCS forces' case default label = '(' // trim ( tostr ( i )) // ')' end select print '(A20,I10,F10.3)' , label , this % counts ( i ), dble ( this % timestamps ( i )) / rate end do end subroutine subroutine printer ( str ) character ( len =* ), intent ( in ) :: str #ifdef WITH_MPI if ( mpi_get_rank () /= 0 ) return #endif print * , str end subroutine subroutine logger_debug ( this , str ) class ( logger_t ), intent ( in ) :: this character ( len =* ), intent ( in ) :: str if ( this % level <= MBD_LOG_LVL_DEBUG ) call this % printer ( str ) end subroutine subroutine logger_info ( this , str ) class ( logger_t ), intent ( in ) :: this character ( len =* ), intent ( in ) :: str if ( this % level <= MBD_LOG_LVL_INFO ) call this % printer ( str ) end subroutine subroutine logger_warn ( this , str ) class ( logger_t ), intent ( in ) :: this character ( len =* ), intent ( in ) :: str if ( this % level <= MBD_LOG_LVL_WARN ) call this % printer ( str ) end subroutine subroutine logger_error ( this , str ) class ( logger_t ), intent ( in ) :: this character ( len =* ), intent ( in ) :: str if ( this % level <= MBD_LOG_LVL_ERROR ) call this % printer ( str ) end subroutine logical function is_true ( val ) result ( res ) logical , intent ( in ), optional :: val res = . false . if ( present ( val )) res = val end function end module","tags":"","loc":"sourcefile/mbd_utils.f90.html"},{"title":"mbd_damping.F90 – Libmbd","text":"Contents Modules mbd_damping Source Code mbd_damping.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. #include \"defaults.h\" module mbd_damping !! Damping functions. use mbd_constants use mbd_gradients , only : grad_scalar_t , grad_request_t use mbd_utils , only : lower , exception_t implicit none private public :: damping_fermi , damping_sqrtfermi , op1minus_grad type , public :: damping_t !! Represents a damping function. character ( len = 20 ) :: version real ( dp ) :: beta = 0 d0 real ( dp ) :: a = MBD_DAMPING_A real ( dp ) :: ts_d = TS_DAMPING_D real ( dp ) :: ts_sr = 0 d0 real ( dp ) :: mayer_scaling = 1 d0 real ( dp ), allocatable :: r_vdw (:) real ( dp ), allocatable :: sigma (:) real ( dp ), allocatable :: damping_custom (:, :) real ( dp ), allocatable :: potential_custom (:, :, :, :) contains procedure :: set_params_from_xc => damping_set_params_from_xc end type contains real ( dp ) function damping_fermi ( r , s_vdw , d , df , grad ) result ( f ) !!  !! \\begin{gathered} !! f_{(ij)}=\\frac1{1+\\exp\\big({-}a(\\eta-1)\\big)},\\qquad !! \\eta=\\frac{R_{(ij)}}{S_{\\text{vdW}(ij)}}\\equiv !! \\frac{R_{(ij)}}{\\beta R_{\\text{vdW}(ij)}} !! \\\\ \\frac{\\mathrm df}{\\mathrm dR_c}= !! \\frac a{2+2\\cosh\\big(a(\\eta-1)\\big)}\\frac{\\mathrm d\\eta}{\\mathrm dR_c},\\qquad !! \\frac{\\mathrm d\\eta}{\\mathrm dR_c}= !! \\frac{R_c}{RS_\\text{vdW}}- !! \\frac{R}{S_\\text{vdW}&#94;2}\\frac{\\mathrm dS_\\text{vdW}}{\\mathrm dR_c} !! \\end{gathered} !!  real ( dp ), intent ( in ) :: r ( 3 ) real ( dp ), intent ( in ) :: s_vdw real ( dp ), intent ( in ) :: d type ( grad_scalar_t ), intent ( out ), optional :: df type ( grad_request_t ), intent ( in ), optional :: grad real ( dp ) :: pre , eta , r_1 r_1 = sqrt ( sum ( r ** 2 )) eta = r_1 / s_vdw f = 1 d0 / ( 1 + exp ( - d * ( eta - 1 ))) if (. not . present ( grad )) return pre = d / ( 2 + 2 * cosh ( d - d * eta )) if ( grad % dcoords ) df % dr = pre * r / ( r_1 * s_vdw ) if ( grad % dr_vdw ) df % dvdw = - pre * r_1 / s_vdw ** 2 end function real ( dp ) function damping_sqrtfermi ( r , s_vdw , d ) result ( f ) real ( dp ), intent ( in ) :: r ( 3 ) real ( dp ), intent ( in ) :: s_vdw real ( dp ), intent ( in ) :: d f = sqrt ( damping_fermi ( r , s_vdw , d )) end function subroutine op1minus_grad ( f , df ) real ( dp ), intent ( inout ) :: f type ( grad_scalar_t ), intent ( inout ) :: df f = 1 - f if ( allocated ( df % dr )) df % dr = - df % dr if ( allocated ( df % dvdw )) df % dvdw = - df % dvdw end subroutine type ( exception_t ) function damping_set_params_from_xc ( this , xc , variant ) result ( exc ) class ( damping_t ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: xc character ( len =* ), intent ( in ) :: variant select case ( lower ( variant )) case ( 'ts' ) select case ( lower ( xc )) case ( 'pbe' ) this % ts_sr = 0.94d0 case ( 'pbe0' ) this % ts_sr = 0.96d0 case ( 'hse' ) this % ts_sr = 0.96d0 case ( 'blyp' ) this % ts_sr = 0.62d0 case ( 'b3lyp' ) this % ts_sr = 0.84d0 case ( 'revpbe' ) this % ts_sr = 0.60d0 case ( 'am05' ) this % ts_sr = 0.84d0 case default exc % code = MBD_EXC_DAMPING exc % msg = 'Damping parameter S_r of method TS unknown for ' // trim ( xc ) end select case ( 'mbd-rsscs' ) select case ( lower ( xc )) case ( 'pbe' ) this % beta = 0.83d0 case ( 'pbe0' ) this % beta = 0.85d0 case ( 'hse' ) this % beta = 0.85d0 case default exc % code = MBD_EXC_DAMPING exc % msg = 'Damping parameter beta of method MBD@rsSCS unknown for ' // trim ( xc ) end select case ( 'mbd-nl' ) select case ( lower ( xc )) case ( 'pbe' ) this % beta = 0.81d0 case ( 'pbe0' ) this % beta = 0.83d0 case ( 'hse' ) this % beta = 0.83d0 case default exc % code = MBD_EXC_DAMPING exc % msg = 'Damping parameter beta of method MBD-NL unknown for ' // trim ( xc ) end select case ( 'mbd-ts' ) select case ( lower ( xc )) case ( 'pbe' ) this % beta = 0.81d0 case ( 'pbe0' ) this % beta = 0.83d0 case ( 'hse' ) this % beta = 0.83d0 case default exc % code = MBD_EXC_DAMPING exc % msg = 'Damping parameter beta of method MBD@TS unknown for ' // trim ( xc ) end select case ( 'mbd-scs' ) select case ( lower ( xc )) case ( 'pbe' ) this % a = 2.56d0 case ( 'pbe0' ) this % a = 2.53d0 case ( 'hse' ) this % a = 2.53d0 case default exc % code = MBD_EXC_DAMPING exc % msg = 'Damping parameter a of method MBD@SCS unknown for ' // trim ( xc ) end select case default exc % code = MBD_EXC_DAMPING exc % msg = 'Damping paramters of method ' // trim ( variant ) // ' unkonwn for ' // trim ( xc ) end select end function end module","tags":"","loc":"sourcefile/mbd_damping.f90.html"},{"title":"mbd_scs.f90 – Libmbd","text":"Contents Modules mbd_scs Source Code mbd_scs.f90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. module mbd_scs !! Performing self-consistent screening. use mbd_constants use mbd_damping , only : damping_t use mbd_dipole , only : dipole_matrix use mbd_formulas , only : sigma_selfint use mbd_geom , only : geom_t use mbd_gradients , only : grad_t , grad_matrix_re_t , grad_request_t use mbd_matrix , only : matrix_re_t , contract_cross_33 use mbd_utils , only : findval implicit none private public :: run_scs contains function run_scs ( geom , alpha , damp , dalpha_scs , grad ) result ( alpha_scs ) !!  !! \\begin{gathered} !! \\bar\\alpha_i=\\tfrac13\\operatorname{Tr} !! \\big(\\textstyle\\sum_j\\boldsymbol{\\bar\\alpha}_{ij}\\big),\\qquad !! \\boldsymbol{\\bar\\alpha}=(\\boldsymbol\\alpha&#94;{-1}+\\mathbf T_\\text{GG})&#94;{-1} !! \\\\ \\partial\\boldsymbol{\\bar\\alpha}= !! -\\boldsymbol{\\bar\\alpha}( !! \\partial\\boldsymbol\\alpha&#94;{-1}+\\partial\\mathbf T_\\text{GG} !! )\\boldsymbol{\\bar\\alpha},\\qquad !! \\frac{\\partial\\bar\\alpha_i}{\\partial X_j}= !! -\\frac13\\sum_{\\zeta\\eta}\\big( !! B_{i\\zeta,j\\eta}\\bar\\alpha'_{\\zeta,j\\eta}+ !! B'_{j\\eta,\\zeta}\\bar\\alpha_{j\\eta,i\\zeta} !! \\big) !! \\\\ \\mathbf B=\\boldsymbol{\\bar\\alpha}\\mathbf A, !! \\quad A_{i\\zeta,j\\eta}= !! \\frac{\\partial(\\alpha_i&#94;{-1})}{\\partial X_i} !! \\delta_{ij}\\delta_{\\zeta\\eta}+ !! \\frac{\\partial T&#94;\\text{GG}_{i\\zeta,j\\eta}}{\\partial X_i},\\quad !! \\bar\\alpha'_{\\zeta,p}=\\sum_i\\bar\\alpha_{i\\zeta,p},\\quad !! B'_{p,\\zeta}=\\sum_iB_{p,i\\zeta} !! \\end{gathered} !!  type ( geom_t ), intent ( inout ) :: geom real ( dp ), intent ( in ) :: alpha (:) type ( damping_t ), intent ( in ) :: damp type ( grad_t ), intent ( out ) :: dalpha_scs (:) type ( grad_request_t ), intent ( in ) :: grad real ( dp ) :: alpha_scs ( size ( alpha )) type ( matrix_re_t ) :: alpha_full , dQ , T integer :: n_atoms , i_xyz , i_atom , my_i_atom , i_latt type ( damping_t ) :: damp_local real ( dp ), allocatable :: dsij_dsi (:), dsigma_dalpha (:), & alpha_prime (:, :), B_prime (:, :), grads_i (:), dalphadA (:) real ( dp ) :: sigma_tmp ( size ( alpha )) ! circumventing PGI 19 compiler bug type ( grad_matrix_re_t ) :: dT type ( grad_request_t ) :: grad_req n_atoms = geom % siz () damp_local = damp sigma_tmp = sigma_selfint ( alpha , dsigma_dalpha , grad % dalpha ) damp_local % sigma = sigma_tmp grad_req = grad_request_t ( & dcoords = grad % dcoords , & dlattice = grad % dlattice , & dsigma = grad % dalpha , & dr_vdw = grad % dr_vdw & ) T = dipole_matrix ( geom , damp_local , dT , grad_req ) if ( geom % has_exc ()) return if ( grad % any ()) then call alpha_full % copy_from ( T ) else call alpha_full % move_from ( T ) end if call alpha_full % add_diag ( 1 d0 / alpha ) call geom % clock ( 32 ) call alpha_full % invh ( geom % exc ) if ( geom % has_exc ()) return call geom % clock ( - 32 ) alpha_scs = alpha_full % contract_n33diag_cols () if ( any ( alpha_scs < 0 )) then geom % exc % code = MBD_EXC_NEG_POL geom % exc % msg = 'Screening leads to negative polarizability' return end if if (. not . grad % any ()) return allocate ( alpha_prime ( 3 , 3 * n_atoms ), source = 0 d0 ) allocate ( B_prime ( 3 * n_atoms , 3 ), source = 0 d0 ) allocate ( grads_i ( n_atoms )) call alpha_full % contract_n_transp ( 'R' , alpha_prime ) call dQ % init_from ( T ) if ( grad % dcoords ) then do my_i_atom = 1 , size ( geom % idx % i_atom ) allocate ( dalpha_scs ( my_i_atom )% dcoords ( size ( geom % idx % j_atom ), 3 )) end do do i_xyz = 1 , 3 dQ % val = - dT % dr (:, :, i_xyz ) dQ = alpha_full % mmul ( dQ ) call dQ % contract_n_transp ( 'C' , B_prime ) do i_atom = 1 , n_atoms grads_i = contract_cross_33 ( & i_atom , dQ , alpha_prime , alpha_full , B_prime & ) my_i_atom = findval ( geom % idx % i_atom , i_atom ) if ( my_i_atom > 0 ) then dalpha_scs ( my_i_atom )% dcoords (:, i_xyz ) = & grads_i ( geom % idx % j_atom ) end if end do end do end if if ( grad % dlattice ) then do my_i_atom = 1 , size ( geom % idx % i_atom ) allocate ( dalpha_scs ( my_i_atom )% dlattice ( 3 , 3 )) end do do i_latt = 1 , 3 do i_xyz = 1 , 3 dQ % val = - dT % dlattice (:, :, i_latt , i_xyz ) dQ = alpha_full % mmul ( dQ ) dQ = dQ % mmul ( alpha_full ) dalphadA = dQ % contract_n33diag_cols () do concurrent ( my_i_atom = 1 : size ( geom % idx % i_atom )) dalpha_scs ( my_i_atom )% dlattice ( i_latt , i_xyz ) & = dalphadA ( geom % idx % i_atom ( my_i_atom )) end do end do end do end if if ( grad % dalpha ) then dQ % val = dT % dsigma do i_atom = 1 , n_atoms dsij_dsi = damp_local % sigma ( i_atom ) * dsigma_dalpha ( i_atom ) / & sqrt ( damp_local % sigma ( i_atom ) ** 2 + damp_local % sigma ** 2 ) call dQ % mult_col ( i_atom , dsij_dsi ) end do call dQ % add_diag ( - 0.5d0 / alpha ** 2 ) dQ = alpha_full % mmul ( dQ ) call dQ % contract_n_transp ( 'C' , B_prime ) do i_atom = 1 , n_atoms grads_i = contract_cross_33 ( & i_atom , dQ , alpha_prime , alpha_full , B_prime & ) my_i_atom = findval ( geom % idx % i_atom , i_atom ) if ( my_i_atom > 0 ) then dalpha_scs ( my_i_atom )% dalpha = grads_i ( geom % idx % j_atom ) end if end do end if if ( grad % dr_vdw ) then dQ % val = dT % dvdw dQ = alpha_full % mmul ( dQ ) call dQ % contract_n_transp ( 'C' , B_prime ) do i_atom = 1 , n_atoms grads_i = contract_cross_33 ( & i_atom , dQ , alpha_prime , alpha_full , B_prime & ) my_i_atom = findval ( geom % idx % i_atom , i_atom ) if ( my_i_atom > 0 ) then dalpha_scs ( my_i_atom )% dr_vdw = grads_i ( geom % idx % j_atom ) end if end do end if end function end module","tags":"","loc":"sourcefile/mbd_scs.f90.html"},{"title":"mbd_geom.F90 – Libmbd","text":"Contents Modules mbd_geom Source Code mbd_geom.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. #ifndef LEGENDRE_PREC #define LEGENDRE_PREC 15 #endif #include \"defaults.h\" module mbd_geom !! Representing a molecule or a crystal unit cell. use mbd_constants use mbd_formulas , only : alpha_dyn_qho , C6_from_alpha , omega_qho use mbd_gradients , only : grad_t , grad_request_t use mbd_lapack , only : eigvals , inverse use mbd_utils , only : & shift_idx , atom_index_t , quad_pt_t , exception_t , tostr , clock_t , printer , & printer_i , logger_t use mbd_vdw_param , only : ts_vdw_params #ifdef WITH_SCALAPACK use mbd_blacs , only : blacs_desc_t , blacs_grid_t #endif #ifdef WITH_MPI use mbd_mpi #endif implicit none private public :: supercell_circum , get_freq_grid type , public :: param_t !! Calculation-wide paramters. real ( dp ) :: dipole_cutoff = 400 d0 * ang ! used only when Ewald is off real ( dp ) :: ewald_real_cutoff_scaling = 1 d0 real ( dp ) :: ewald_rec_cutoff_scaling = 1 d0 real ( dp ) :: k_grid_shift = K_GRID_SHIFT logical :: ewald_on = . true . logical :: zero_negative_eigvals = . false . logical :: rpa_rescale_eigs = . false . integer :: rpa_order_max = 10 integer :: n_freq = N_FREQUENCY_GRID end type type , public :: geom_t !! Represents a molecule or a crystal unit cell. !! !! The documented variables should be set before calling the initializer. real ( dp ), allocatable :: coords (:, :) !! (3\\times N, a.u.) Atomic coordinates. real ( dp ), allocatable :: lattice (:, :) !! (3\\times 3, a.u.) Lattice vectors in columns, unallocated if not !! periodic. integer , allocatable :: k_grid (:) !! Number of k-points along reciprocal axes. real ( dp ), allocatable :: custom_k_pts (:, :) !! Custom k-point grid. character ( len = 10 ) :: parallel_mode = 'auto' !! Type of parallelization: !! !! - `atoms`: distribute matrices over all MPI tasks using ScaLAPACK, !! solve eigenproblems sequentialy. !! - `k_points`: parallelize over k-points (each MPI task solves entire !! eigenproblems for its k-points) logical :: get_eigs = . false . !! Whether to keep MBD eigenvalues logical :: get_modes = . false . !! Whether to calculate MBD eigenvectors logical :: do_rpa = . false . !! Whether to calculate MBD energy by frequency integration logical :: get_rpa_orders = . false . !! Whether to calculate RPA orders type ( logger_t ) :: log !! Used for logging #ifdef WITH_MPI integer :: mpi_comm = MPI_COMM_WORLD !! MPI communicator #endif #ifdef WITH_SCALAPACK integer :: max_atoms_per_block = MAX_ATOMS_PER_BLOCK #endif ! The following components are set by the initializer and should be ! considered read-only type ( clock_t ) :: timer type ( exception_t ) :: exc type ( quad_pt_t ), allocatable :: freq (:) real ( dp ) :: gamm = 0 d0 real ( dp ) :: real_space_cutoff real ( dp ) :: rec_space_cutoff type ( param_t ) :: param type ( atom_index_t ) :: idx #ifdef WITH_SCALAPACK ! TODO makes these two private (see use in mbd_methods, mbd_dipole) type ( blacs_desc_t ) :: blacs type ( blacs_grid_t ) :: blacs_grid #endif #ifdef WITH_MPI integer :: mpi_size = - 1 integer :: mpi_rank = - 1 #endif contains procedure :: init => geom_init procedure :: destroy => geom_destroy procedure :: siz => geom_siz procedure :: has_exc => geom_has_exc procedure :: clock => geom_clock end type contains subroutine geom_init ( this ) class ( geom_t ), intent ( inout ) :: this integer :: i_atom real ( dp ) :: volume , freq_grid_err logical :: is_parallel #ifdef WITH_MPI logical :: can_parallel_kpts integer :: ierr , n_kpts #endif if (. not . associated ( this % log % printer )) this % log % printer => printer associate ( n => this % param % n_freq ) allocate ( this % freq ( 0 : n )) call get_freq_grid ( n , this % freq ( 1 : n )% val , this % freq ( 1 : n )% weight ) end associate this % freq ( 0 )% val = 0 d0 this % freq ( 0 )% weight = 0 d0 freq_grid_err = test_frequency_grid ( this % freq ) call this % log % info ( 'Frequency grid relative error: ' // tostr ( freq_grid_err )) call this % timer % init ( 100 ) if ( allocated ( this % lattice )) then volume = abs ( dble ( product ( eigvals ( this % lattice )))) if ( this % param % ewald_on ) then this % gamm = 2.5d0 / volume ** ( 1 d0 / 3 ) this % real_space_cutoff = 6 d0 / this % gamm * this % param % ewald_real_cutoff_scaling this % rec_space_cutoff = 10 d0 * this % gamm * this % param % ewald_rec_cutoff_scaling else this % real_space_cutoff = this % param % dipole_cutoff end if end if #ifdef WITH_MPI call MPI_COMM_SIZE ( this % mpi_comm , this % mpi_size , ierr ) call MPI_COMM_RANK ( this % mpi_comm , this % mpi_rank , ierr ) if ( allocated ( this % custom_k_pts )) then n_kpts = size ( this % custom_k_pts , 2 ) else if ( allocated ( this % k_grid )) then n_kpts = product ( this % k_grid ) else n_kpts = - 1 end if can_parallel_kpts = allocated ( this % lattice ) . and . n_kpts > 0 . and . this % mpi_size > 1 if ( this % parallel_mode == 'auto' . and . can_parallel_kpts . and . this % siz () ** 2 < n_kpts ) then this % parallel_mode = 'k_points' end if #endif #ifdef WITH_SCALAPACK this % idx % parallel = . false . if ( this % parallel_mode == 'auto' . or . this % parallel_mode == 'atoms' ) then #   ifdef WITH_MPI call this % blacs_grid % init ( this % mpi_comm ) #   else call this % blacs_grid % init () #   endif call this % blacs % init ( this % siz (), this % blacs_grid , this % max_atoms_per_block ) if ( allocated ( this % blacs % i_atom )) then this % parallel_mode = 'atoms' this % idx % parallel = . true . this % idx % i_atom = this % blacs % i_atom this % idx % j_atom = this % blacs % j_atom else call this % blacs_grid % destroy () end if end if #endif #ifdef WITH_MPI if ( this % parallel_mode == 'auto' . and . can_parallel_kpts ) then this % parallel_mode = 'k_points' end if #endif if ( this % parallel_mode == 'auto' ) this % parallel_mode = 'none' #ifdef WITH_SCALAPACK is_parallel = this % idx % parallel #else is_parallel = . false . #endif if (. not . is_parallel ) then this % idx % i_atom = [( i_atom , i_atom = 1 , this % siz ())] this % idx % j_atom = this % idx % i_atom end if this % idx % n_atoms = this % siz () call this % log % info ( 'Will use parallel mode: ' // this % parallel_mode ) #ifdef WITH_SCALAPACK if ( this % idx % parallel ) then call this % log % info ( 'BLACS block size: ' // tostr ( this % blacs % blocksize )) end if #endif end subroutine subroutine geom_destroy ( this ) class ( geom_t ), intent ( inout ) :: this #ifdef WITH_SCALAPACK if ( this % idx % parallel ) call this % blacs_grid % destroy () #endif deallocate ( this % freq ) deallocate ( this % timer % timestamps ) deallocate ( this % timer % counts ) end subroutine integer function geom_siz ( this ) result ( siz ) class ( geom_t ), intent ( in ) :: this if ( allocated ( this % coords )) then siz = size ( this % coords , 2 ) else siz = 0 end if end function logical function geom_has_exc ( this ) result ( has_exc ) class ( geom_t ), intent ( in ) :: this has_exc = this % exc % code /= 0 end function function supercell_circum ( lattice , radius ) result ( sc ) real ( dp ), intent ( in ) :: lattice ( 3 , 3 ) real ( dp ), intent ( in ) :: radius integer :: sc ( 3 ) real ( dp ) :: ruc ( 3 , 3 ), layer_sep ( 3 ) integer :: i ruc = 2 * pi * inverse ( transpose ( lattice )) do concurrent ( i = 1 : 3 ) layer_sep ( i ) = sum ( lattice (:, i ) * ruc (:, i ) / sqrt ( sum ( ruc (:, i ) ** 2 ))) end do sc = ceiling ( radius / layer_sep + 0.5d0 ) end function subroutine geom_clock ( this , id ) class ( geom_t ), intent ( inout ) :: this integer , intent ( in ) :: id call this % timer % clock ( id ) end subroutine subroutine get_freq_grid ( n , x , w , L ) integer , intent ( in ) :: n real ( dp ), intent ( out ) :: x ( n ), w ( n ) real ( dp ), intent ( in ), optional :: L real ( dp ) :: L_ if ( present ( L )) then L_ = L else L_ = 0.6d0 end if call gauss_legendre ( n , x , w ) w = 2 * L_ / ( 1 - x ) ** 2 * w x = L_ * ( 1 + x ) / ( 1 - x ) w = w ( n : 1 : - 1 ) x = x ( n : 1 : - 1 ) end subroutine subroutine gauss_legendre ( n , r , w ) integer , intent ( in ) :: n real ( dp ), intent ( out ) :: r ( n ), w ( n ) integer , parameter :: q = selected_real_kind ( LEGENDRE_PREC ) integer , parameter :: n_iter = 1000 real ( q ) :: x , f , df , dx integer :: k , iter , i real ( q ) :: Pk ( 0 : n ), Pk1 ( 0 : n - 1 ), Pk2 ( 0 : n - 2 ) if ( n == 1 ) then r ( 1 ) = 0 d0 w ( 1 ) = 2 d0 return end if Pk2 ( 0 ) = 1._q ! k = 0 Pk1 ( 0 : 1 ) = [ 0._q , 1._q ] ! k = 1 do k = 2 , n Pk ( 0 : k ) = (( 2 * k - 1 ) * & [ 0._q , Pk1 ( 0 : k - 1 )] - ( k - 1 ) * [ Pk2 ( 0 : k - 2 ), 0._q , 0._q ]) / k if ( k < n ) then Pk2 ( 0 : k - 1 ) = Pk1 ( 0 : k - 1 ) Pk1 ( 0 : k ) = Pk ( 0 : k ) end if end do ! now Pk contains k-th Legendre polynomial do i = 1 , n x = cos ( pi * ( i - 0.25_q ) / ( n + 0.5_q )) do iter = 1 , n_iter df = 0._q f = Pk ( n ) do k = n - 1 , 0 , - 1 df = f + x * df f = Pk ( k ) + x * f end do dx = f / df x = x - dx if ( abs ( dx ) < 10 * epsilon ( dx )) exit end do r ( i ) = dble ( x ) w ( i ) = dble ( 2 / (( 1 - x ** 2 ) * df ** 2 )) end do end subroutine real ( dp ) function test_frequency_grid ( freq ) result ( error ) !! Calculate relative quadrature error in C6 of a carbon atom type ( quad_pt_t ), intent ( in ) :: freq ( 0 :) real ( dp ) :: alpha ( 1 , 0 : ubound ( freq , 1 )), C6 ( 1 ), C6_ref ( 1 ), w ( 1 ), a0 ( 1 ) type ( grad_t ), allocatable :: dalpha (:) type ( grad_request_t ) :: grad a0 ( 1 ) = ts_vdw_params ( 1 , 6 ) C6_ref ( 1 ) = ts_vdw_params ( 2 , 6 ) w = omega_qho ( C6_ref , a0 ) alpha = alpha_dyn_qho ( a0 , w , freq , dalpha , grad ) C6 = C6_from_alpha ( alpha , freq ) error = abs ( C6 ( 1 ) / C6_ref ( 1 ) - 1 d0 ) end function end module","tags":"","loc":"sourcefile/mbd_geom.f90.html"},{"title":"mbd_hamiltonian.F90 – Libmbd","text":"Contents Modules mbd_hamiltonian Source Code mbd_hamiltonian.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. #ifndef DO_COMPLEX_TYPE module mbd_hamiltonian !! Forming and solving MBD Hamiltonian. use mbd_constants use mbd_damping , only : damping_t use mbd_dipole , only : dipole_matrix use mbd_geom , only : geom_t use mbd_gradients , only : grad_t , grad_matrix_re_t , grad_matrix_cplx_t , grad_request_t use mbd_matrix , only : matrix_re_t , matrix_cplx_t use mbd_utils , only : result_t , tostr implicit none private public :: get_mbd_hamiltonian_energy interface get_mbd_hamiltonian_energy !! Form and solve either a real or a complex MBD Hamiltonian. !! !! The real-typed version is equivalent to \\mathbf q=0. !! !!  !! \\begin{gathered} !! E_\\text{MBD}(\\mathbf q)=\\frac12\\operatorname{Tr}\\big(\\sqrt{\\mathbf Q(\\mathbf !! q)}\\big)- 3\\sum_i\\frac{\\omega_i}2,\\qquad !! \\mathbf Q_{ij}(\\mathbf q)=\\omega_i&#94;2\\delta_{ij}\\mathbf I+ !! \\omega_i\\omega_j\\sqrt{\\alpha_{0,i}\\alpha_{0,j}}\\mathbf T_{ij}(\\mathbf q) !! \\\\ \\mathbf Q(\\mathbf q)\\equiv !! \\mathbf C(\\mathbf q)\\boldsymbol\\Lambda(\\mathbf q)\\mathbf C(\\mathbf !! q)&#94;\\dagger,\\qquad !! \\boldsymbol\\Lambda(\\mathbf q) !! \\equiv\\operatorname{diag}(\\{\\tilde\\omega_i(\\mathbf q)&#94;2\\}),\\qquad !! \\operatorname{Tr}\\big(\\sqrt{\\mathbf Q(\\mathbf q)}\\big) !! =\\sum_i\\tilde\\omega_i(\\mathbf q) !! \\end{gathered} !!  !! !!  !! \\begin{aligned} !! \\partial E_\\text{MBD}&=\\frac14\\operatorname{Tr}\\big( !! \\mathbf C\\boldsymbol\\Lambda&#94;{-\\frac12}\\mathbf C&#94;\\dagger !! \\partial\\mathbf Q !! \\big)- !! 3\\sum_i\\frac{\\partial\\omega_i}2 !! \\\\ \\frac{\\partial E_\\text{MBD}}{\\partial X_i}&= !! \\operatorname{Re}\\frac12\\sum_{p\\zeta}( !! \\mathbf C\\boldsymbol\\Lambda&#94;{-\\frac12}\\mathbf C&#94;\\dagger !! )_{i\\zeta,p} !! \\frac{\\partial Q_{p,i\\zeta}}{\\partial X_i}- !! \\frac32\\frac{\\partial\\omega_i}{\\partial X_i} !! \\end{aligned} !!  !! !!  !! \\begin{aligned} !! \\partial\\mathbf Q_{ij}=& !! 2\\delta_{ij}\\omega_i\\partial\\omega_i\\mathbf I+ !! \\omega_i\\omega_j\\sqrt{\\alpha_{0,i}\\alpha_{0,j}}\\mathbf T_{ij}\\left( !! \\frac{\\partial\\omega_i}{\\omega_i}+ !! \\frac{\\partial\\omega_j}{\\omega_j}+ !! \\frac12\\frac{\\partial\\alpha_{0,i}}{\\alpha_{0,i}}+ !! \\frac12\\frac{\\partial\\alpha_{0,j}}{\\alpha_{0,j}} !! \\right) !! \\\\ &+\\omega_i\\omega_j\\sqrt{\\alpha_{0,i}\\alpha_{0,j}} !! \\partial\\mathbf T_{ij} !! \\end{aligned} !!  module procedure get_mbd_hamiltonian_energy_real module procedure get_mbd_hamiltonian_energy_complex end interface contains #endif #ifndef DO_COMPLEX_TYPE type ( result_t ) function get_mbd_hamiltonian_energy_real ( & geom , alpha_0 , omega , damp , grad ) result ( res ) #else type ( result_t ) function get_mbd_hamiltonian_energy_complex ( & geom , alpha_0 , omega , damp , grad , q ) result ( res ) #endif type ( geom_t ), intent ( inout ) :: geom real ( dp ), intent ( in ) :: alpha_0 (:) real ( dp ), intent ( in ) :: omega (:) type ( damping_t ), intent ( in ) :: damp type ( grad_request_t ), intent ( in ) :: grad #ifdef DO_COMPLEX_TYPE real ( dp ), intent ( in ) :: q ( 3 ) #endif #ifndef DO_COMPLEX_TYPE type ( matrix_re_t ) :: relay , dQ , T , modes , c_lambda12i_c type ( grad_matrix_re_t ) :: dT #else type ( matrix_cplx_t ) :: relay , dQ , T , modes , c_lambda12i_c type ( grad_matrix_cplx_t ) :: dT #endif real ( dp ), allocatable :: eigs (:) integer :: n_negative_eigs , n_atoms , i_xyz , i_latt character ( 120 ) :: msg n_atoms = geom % siz () #ifndef DO_COMPLEX_TYPE T = dipole_matrix ( geom , damp , dT , grad ) #else T = dipole_matrix ( geom , damp , dT , grad , q ) #endif if ( geom % has_exc ()) return if ( grad % any ()) then call relay % copy_from ( T ) else call relay % move_from ( T ) end if call relay % mult_cross ( omega * sqrt ( alpha_0 )) call relay % add_diag ( omega ** 2 ) call geom % clock ( 21 ) if ( geom % get_modes . or . grad % any ()) then call modes % alloc_from ( relay ) allocate ( eigs ( 3 * n_atoms )) call modes % eigh ( eigs , geom % exc , src = relay ) if ( geom % get_modes ) then #ifndef DO_COMPLEX_TYPE call move_alloc ( modes % val , res % modes ) #else call move_alloc ( modes % val , res % modes_k_single ) #endif end if else eigs = relay % eigvalsh ( geom % exc , destroy = . true .) end if if ( geom % has_exc ()) return call geom % clock ( - 21 ) if ( geom % get_eigs ) res % mode_eigs = eigs n_negative_eigs = count ( eigs (:) < 0 ) if ( n_negative_eigs > 0 ) then msg = \"CDM Hamiltonian has \" // trim ( tostr ( n_negative_eigs )) // & \" negative eigenvalues\" if ( geom % param % zero_negative_eigvals ) then where ( eigs < 0 ) eigs = 0 d0 call geom % log % warn ( msg ) else geom % exc % code = MBD_EXC_NEG_EIGVALS geom % exc % msg = msg return end if end if res % energy = 1 d0 / 2 * sum ( sqrt ( eigs )) - 3 d0 / 2 * sum ( omega ) if (. not . grad % any ()) return call geom % clock ( 25 ) call c_lambda12i_c % copy_from ( modes ) call c_lambda12i_c % mult_cols_3n ( eigs ** ( - 1 d0 / 4 )) c_lambda12i_c = c_lambda12i_c % mmul ( c_lambda12i_c , transB = 'C' ) #ifdef DO_COMPLEX_TYPE c_lambda12i_c % val = conjg ( c_lambda12i_c % val ) #endif call dQ % init_from ( T ) if ( grad % dcoords ) then allocate ( res % dE % dcoords ( n_atoms , 3 )) do i_xyz = 1 , 3 dQ % val = dT % dr (:, :, i_xyz ) call dQ % mult_cross ( omega * sqrt ( alpha_0 )) dQ % val = c_lambda12i_c % val * dQ % val res % dE % dcoords (:, i_xyz ) = 1 d0 / 2 * dble ( dQ % contract_n33_rows ()) end do end if if ( grad % dlattice ) then allocate ( res % dE % dlattice ( 3 , 3 )) do i_latt = 1 , 3 do i_xyz = 1 , 3 dQ % val = dT % dlattice (:, :, i_latt , i_xyz ) call dQ % mult_cross ( omega * sqrt ( alpha_0 )) dQ % val = c_lambda12i_c % val * dQ % val res % dE % dlattice ( i_latt , i_xyz ) = 1 d0 / 4 * dble ( dQ % sum_all ()) end do end do end if if ( grad % dalpha ) then dQ % val = T % val call dQ % mult_cross ( omega * sqrt ( alpha_0 )) call dQ % mult_rows ( 1 d0 / ( 2 * alpha_0 )) dQ % val = c_lambda12i_c % val * dQ % val res % dE % dalpha = 1 d0 / 2 * dble ( dQ % contract_n33_rows ()) end if if ( grad % domega ) then dQ % val = T % val call dQ % mult_cross ( omega * sqrt ( alpha_0 )) call dQ % mult_rows ( 1 d0 / omega ) call dQ % add_diag ( omega ) dQ % val = c_lambda12i_c % val * dQ % val res % dE % domega = 1 d0 / 2 * dble ( dQ % contract_n33_rows ()) - 3 d0 / 2 end if if ( grad % dr_vdw ) then dQ % val = dT % dvdw call dQ % mult_cross ( omega * sqrt ( alpha_0 )) dQ % val = c_lambda12i_c % val * dQ % val res % dE % dr_vdw = 1 d0 / 2 * dble ( dQ % contract_n33_rows ()) end if #ifdef DO_COMPLEX_TYPE if ( grad % dq ) then allocate ( res % dE % dq ( 3 )) do i_latt = 1 , 3 dQ % val = dT % dq (:, :, i_latt ) call dQ % mult_cross ( omega * sqrt ( alpha_0 )) dQ % val = c_lambda12i_c % val * dQ % val res % dE % dq ( i_latt ) = 1 d0 / 4 * dble ( dQ % sum_all ()) end do end if #endif call geom % clock ( - 25 ) end function #ifndef DO_COMPLEX_TYPE #   define DO_COMPLEX_TYPE #   include \"mbd_hamiltonian.F90\" end module #endif","tags":"","loc":"sourcefile/mbd_hamiltonian.f90.html"},{"title":"mbd_input_t – Libmbd ","text":"type, public :: mbd_input_t Contains user input to an MBD calculation. Contents Variables method comm max_atoms_per_block log_level printer calculate_forces calculate_vdw_params_gradients calculate_spectrum do_rpa rpa_orders rpa_rescale_eigs n_omega_grid k_grid_shift zero_negative_eigvals xc ts_d ts_sr mbd_a mbd_beta vdw_params_kind atom_types free_values coords lattice_vectors k_grid parallel_mode Components Type Visibility Attributes Name Initial character(len=30), public :: method = 'mbd-rsscs' VdW method to use to calculate energy and gradients. mbd-rsscs : The MBD@rsSCS method. mbd-nl : The MBD-NL method. ts : The TS method. mbd : Generic MBD method (without any screening). integer, public :: comm = -1 MPI communicator. Only used when compiled with MPI. Leave as is to use the\n MPI_COMM_WORLD communicator. integer, public :: max_atoms_per_block = 6 Number of atoms per block in a BLACS grid. integer, public :: log_level = MBD_LOG_LVL_INFO Level of printing procedure(printer_i), public, nopass, pointer :: printer => null() If assigned, will be used for logging logical, public :: calculate_forces = .true. Whether to calculate forces. logical, public :: calculate_vdw_params_gradients = .false. Whether to calculate gradients of energy w.r.t. vdW parameters logical, public :: calculate_spectrum = .false. Whether to keep MBD eigenvalues. logical, public :: do_rpa = .false. Whether to evalulate the MBD energy as an RPA integral over frequency. logical, public :: rpa_orders = .false. Whether to calculate individual RPA orders logical, public :: rpa_rescale_eigs = .false. Whether to rescale RPA eigenvalues as in 10.1021/acs.jctc.6b00925. integer, public :: n_omega_grid = 15 Number of imaginary frequency grid points. real(kind=dp), public :: k_grid_shift = 0.5d0 Off- shift of the -point grid in units of\n inter- -point distance. logical, public :: zero_negative_eigvals = .false. Whether to zero out negative eigenvalues. character(len=20), public :: xc = '' XC functional for automatic setting of damping parameters. real(kind=dp), public :: ts_d = 20d0 TS damping parameter . real(kind=dp), public :: ts_sr = -1 Custom TS damping parameter . Leave as is to use a value based on the XC functional. real(kind=dp), public :: mbd_a = 6d0 MBD damping parameter . real(kind=dp), public :: mbd_beta = -1 Custom MBD damping parameter . Leave as is to use a value based on the XC functional. character(len=10), public :: vdw_params_kind = 'ts' Which free-atom reference vdW parameters to use for scaling. ts : Values from original TS method. tssurf : Values from the TS approach. character(len=3), public, allocatable :: atom_types (:) ( ) Atom types used for picking free-atom reference values. real(kind=dp), public, allocatable :: free_values (:,:) ( , a.u.) Custom free-atom vdW paramters to use for\n scaling. Columns contain static polarizabilities, C6 coefficients, and vdW\n radii. real(kind=dp), public, allocatable :: coords (:,:) ( , a.u.) Atomic coordinates. real(kind=dp), public, allocatable :: lattice_vectors (:,:) ( , a.u.) Lattice vectors in columns, unallocated if not\n periodic. integer, public :: k_grid (3) = [-1, -1, -1] Number of -points along reciprocal axes. character(len=10), public :: parallel_mode = 'auto' Parallelization scheme. auto : Pick based on system system size and number of -points. kpoints : Parallelize over -points. atoms : Parallelize over atom pairs.","tags":"","loc":"type/mbd_input_t.html"},{"title":"mbd_calc_t – Libmbd ","text":"type, public :: mbd_calc_t Represents an MBD calculation. Contents Type-Bound Procedures init destroy switch_forces update_coords update_lattice_vectors update_vdw_params_custom update_vdw_params_from_ratios update_vdw_params_nl evaluate_vdw_method get_gradients get_vdw_params_ratios_gradients get_lattice_derivs get_lattice_stress get_spectrum_modes get_rpa_orders get_exception Type-Bound Procedures procedure, public :: init => mbd_calc_init private subroutine mbd_calc_init(this, input) Initialize an MBD calculation from an MBD input. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout), target :: this type( mbd_input_t ), intent(in) :: input MBD input. procedure, public :: destroy => mbd_calc_destroy private subroutine mbd_calc_destroy(this) Finalize an MBD calculation. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout), target :: this procedure, public :: switch_forces => mbd_calc_switch_forces private subroutine mbd_calc_switch_forces(this, forces) Update whether to calculate forces. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this logical, intent(in) :: forces Whether to calcualte forces. procedure, public :: update_coords => mbd_calc_update_coords private subroutine mbd_calc_update_coords(this, coords) Update atomic coordinates. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(in) :: coords (:,:) ( , a.u.) New atomic coordinates. procedure, public :: update_lattice_vectors => mbd_calc_update_lattice_vectors private subroutine mbd_calc_update_lattice_vectors(this, latt_vecs) Update unit-cell lattice vectors. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(in) :: latt_vecs (:,:) ( , a.u.) New lattice vectors in columns. procedure, public :: update_vdw_params_custom => mbd_calc_update_vdw_params_custom private subroutine mbd_calc_update_vdw_params_custom(this, alpha_0, C6, r_vdw) Update vdW parameters in a custom way. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(in) :: alpha_0 (:) (a.u.) New atomic static polarizabilities. real(kind=dp), intent(in) :: C6 (:) (a.u.) New atomic coefficients. real(kind=dp), intent(in) :: r_vdw (:) (a.u.) New atomic vdW radii. procedure, public :: update_vdw_params_from_ratios => mbd_calc_update_vdw_params_from_ratios private subroutine mbd_calc_update_vdw_params_from_ratios(this, ratios) Update vdW parameters based on scaling of free-atom values. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(in) :: ratios (:) Ratios of atomic volumes in the system and in vacuum. procedure, public :: update_vdw_params_nl => mbd_calc_update_vdw_params_nl private subroutine mbd_calc_update_vdw_params_nl(this, alpha_0_ratios, C6_ratios) Update vdW parameters for the MBD-NL method. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(in) :: alpha_0_ratios (:) Ratios of free-atom exact static polarizabilities and those from the\n VV functional. real(kind=dp), intent(in) :: C6_ratios (:) Ratios of free-atom exact coefficients and those from the VV\n functional. procedure, public :: evaluate_vdw_method => mbd_calc_evaluate_vdw_method private subroutine mbd_calc_evaluate_vdw_method(this, energy) Evaluate a given vdW method for a given system and vdW parameters,\n retrieve energy. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(out) :: energy (a.u.) VdW energy. procedure, public :: get_gradients => mbd_calc_get_gradients private subroutine mbd_calc_get_gradients(this, gradients) Retrieve nuclear energy gradients if they were requested in the MBD\n input. The gradients are calculated together with the energy, so a call to this\n method must be preceeded by a call to evaluate_vdw_method .  For the same reason, the\n gradients must be requested prior to this called via calculate_forces . Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(in) :: this real(kind=dp), intent(out) :: gradients (:,:) ( , a.u.) Energy gradients, , index runs over columns. procedure, public :: get_vdw_params_ratios_gradients => mbd_calc_get_vdw_params_ratios_gradients private subroutine mbd_calc_get_vdw_params_ratios_gradients(this, dE_dratios) Get gradients of the energy w.r.t. Hirshfeld ratios if they were\n requested in the MBD input. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(out) :: dE_dratios (:) Gradients of the energy w.r.t. Hirshfeld ratios. procedure, public :: get_lattice_derivs => mbd_calc_get_lattice_derivs private subroutine mbd_calc_get_lattice_derivs(this, latt_derivs) Provide lattice-vector energy gradients if they were requested in the MBD\n input. The gradients are actually calculated together with the energy, so a call\n to this method must be preceeded by a call to evaluate_vdw_method .  For the same reason, the\n gradients must be requested prior to this called via calculate_forces . Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(in) :: this real(kind=dp), intent(out) :: latt_derivs (:,:) ( , a.u.) Energy gradients, , index runs over columns. procedure, public :: get_lattice_stress => mbd_calc_get_lattice_stress private subroutine mbd_calc_get_lattice_stress(this, stress) Provide stress tensor of the lattice. This is a utility function wrapping get_lattice_derivs .\n The lattice vector gradients are coverted to the stress tensor. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(in) :: this real(kind=dp), intent(out) :: stress (:,:) ( , a.u.) Stress tensor. procedure, public :: get_spectrum_modes => mbd_calc_get_spectrum_modes private subroutine mbd_calc_get_spectrum_modes(this, spectrum, modes) Provide MBD spectrum if it was requested in the MBD input. The spectrum is actually calculated together with the energy, so a call\n to this method must be preceeded by a call to evaluate_vdw_method .  For the same reason, the\n spectrum must be requested prior to this call via calculate_spectrum . Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(out) :: spectrum (:) ( , a.u.) Energies (frequencies) of coupled MBD modues, . real(kind=dp), intent(out), optional allocatable :: modes (:,:) ( ) Coupled-mode wave functions (MBD eigenstates), , in the basis of uncoupled states, , index runs over\n columns. To save memory, the argument must be allocatable, and the method\n transfers allocation from the internal state to the argument. For\n this reason, the method can be called only once wih this optional\n argument per calculation. procedure, public :: get_rpa_orders => mbd_calc_get_rpa_orders private subroutine mbd_calc_get_rpa_orders(this, rpa_orders) Provide RPA orders if they were requested in the MBD input. The orders are actually calculated together with the energy, so a call\n to this method must be preceeded by a call to evaluate_vdw_method . For the same reason, the\n spectrum must be requested prior to this call via do_rpa and rpa_orders . Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(out), allocatable :: rpa_orders (:) (a.u.) MBD energy decomposed to RPA orders. procedure, public :: get_exception => mbd_calc_get_exception private subroutine mbd_calc_get_exception(this, code, origin, msg) Retrieve an exception in the MBD calculation if it occured. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this integer, intent(out) :: code Exception code, values defined in mbd_constants . character(len=*), intent(out) :: origin Exception origin. character(len=*), intent(out) :: msg Exception message.","tags":"","loc":"type/mbd_calc_t.html"},{"title":"grad_t – Libmbd ","text":"type, public :: grad_t Derivatives with respect to various quantities Contents Variables dcoords dlattice dalpha dalpha_dyn dC6 dq dr_vdw domega dV dV_free dX_free Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dcoords (:,:) real(kind=dp), public, allocatable :: dlattice (:,:) real(kind=dp), public, allocatable :: dalpha (:) real(kind=dp), public, allocatable :: dalpha_dyn (:,:) real(kind=dp), public, allocatable :: dC6 (:) real(kind=dp), public, allocatable :: dq (:) real(kind=dp), public, allocatable :: dr_vdw (:) real(kind=dp), public, allocatable :: domega (:) real(kind=dp), public, allocatable :: dV (:) real(kind=dp), public, allocatable :: dV_free (:) real(kind=dp), public, allocatable :: dX_free (:)","tags":"","loc":"type/grad_t.html"},{"title":"grad_matrix_re_t – Libmbd ","text":"type, public :: grad_matrix_re_t Derivatives of a real dipole matrix with respect to various quantities Contents Variables dr dlattice dvdw dsigma dgamma Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dr (:,:,:) real(kind=dp), public, allocatable :: dlattice (:,:,:,:) real(kind=dp), public, allocatable :: dvdw (:,:) real(kind=dp), public, allocatable :: dsigma (:,:) real(kind=dp), public, allocatable :: dgamma (:,:)","tags":"","loc":"type/grad_matrix_re_t.html"},{"title":"grad_matrix_cplx_t – Libmbd ","text":"type, public :: grad_matrix_cplx_t Derivatives of a compelx dipole matrix with respect to various quantities Contents Variables dr dlattice dq dvdw dsigma dgamma Components Type Visibility Attributes Name Initial complex(kind=dp), public, allocatable :: dr (:,:,:) complex(kind=dp), public, allocatable :: dlattice (:,:,:,:) complex(kind=dp), public, allocatable :: dq (:,:,:) complex(kind=dp), public, allocatable :: dvdw (:,:) complex(kind=dp), public, allocatable :: dsigma (:,:) complex(kind=dp), public, allocatable :: dgamma (:,:)","tags":"","loc":"type/grad_matrix_cplx_t.html"},{"title":"grad_scalar_t – Libmbd ","text":"type, public :: grad_scalar_t Derivatives of a scalar with respect to various quantities Contents Variables dr dr_1 dk_1 dvdw dgamma dC6 dC6i dC6j da0i da0j Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dr (:) real(kind=dp), public, allocatable :: dr_1 real(kind=dp), public, allocatable :: dk_1 real(kind=dp), public, allocatable :: dvdw real(kind=dp), public, allocatable :: dgamma real(kind=dp), public, allocatable :: dC6 real(kind=dp), public, allocatable :: dC6i real(kind=dp), public, allocatable :: dC6j real(kind=dp), public, allocatable :: da0i real(kind=dp), public, allocatable :: da0j","tags":"","loc":"type/grad_scalar_t.html"},{"title":"grad_request_t – Libmbd ","text":"type, public :: grad_request_t Used to request derivatives with respect to function arguments Contents Variables dcoords dalpha dalpha_dyn dC6 dr_vdw domega dsigma dgamma dq dlattice dV dV_free dX_free Type-Bound Procedures any Components Type Visibility Attributes Name Initial logical, public :: dcoords = .false. logical, public :: dalpha = .false. logical, public :: dalpha_dyn = .false. logical, public :: dC6 = .false. logical, public :: dr_vdw = .false. logical, public :: domega = .false. logical, public :: dsigma = .false. logical, public :: dgamma = .false. logical, public :: dq = .false. logical, public :: dlattice = .false. logical, public :: dV = .false. logical, public :: dV_free = .false. logical, public :: dX_free = .false. Type-Bound Procedures procedure, public :: any => grad_request_any private function grad_request_any(this) result(any) Arguments Type Intent Optional Attributes Name class( grad_request_t ), intent(in) :: this Return Value logical","tags":"","loc":"type/grad_request_t.html"},{"title":"exception_t – Libmbd ","text":"type, public :: exception_t Represents an exception. Contents Variables code origin msg Components Type Visibility Attributes Name Initial integer, public :: code = 0 character(len=50), public :: origin = '(unknown)' character(len=150), public :: msg = ''","tags":"","loc":"type/exception_t.html"},{"title":"result_t – Libmbd ","text":"type, public :: result_t Stores results from an MBD calculation Contents Variables energy dE mode_eigs modes rpa_orders mode_eigs_k modes_k modes_k_single rpa_orders_k Components Type Visibility Attributes Name Initial real(kind=dp), public :: energy type( grad_t ), public :: dE real(kind=dp), public, allocatable :: mode_eigs (:) real(kind=dp), public, allocatable :: modes (:,:) real(kind=dp), public, allocatable :: rpa_orders (:) real(kind=dp), public, allocatable :: mode_eigs_k (:,:) complex(kind=dp), public, allocatable :: modes_k (:,:,:) complex(kind=dp), public, allocatable :: modes_k_single (:,:) real(kind=dp), public, allocatable :: rpa_orders_k (:,:)","tags":"","loc":"type/result_t.html"},{"title":"atom_index_t – Libmbd ","text":"type, public :: atom_index_t Maps from atom indexes to positions in matrices. Contents Variables i_atom j_atom n_atoms parallel Components Type Visibility Attributes Name Initial integer, public, allocatable :: i_atom (:) integer, public, allocatable :: j_atom (:) integer, public :: n_atoms logical, public :: parallel","tags":"","loc":"type/atom_index_t.html"},{"title":"clock_t – Libmbd ","text":"type, public :: clock_t Used for measuring performance. Contents Variables active timestamps counts Type-Bound Procedures init clock print Components Type Visibility Attributes Name Initial logical, public :: active = .true. integer(kind=i8), public, allocatable :: timestamps (:) integer(kind=i8), public, allocatable :: counts (:) Type-Bound Procedures procedure, public :: init => clock_init private subroutine clock_init(this, n) Arguments Type Intent Optional Attributes Name class( clock_t ), intent(inout) :: this integer, intent(in) :: n procedure, public :: clock => clock_clock private subroutine clock_clock(this, id) Arguments Type Intent Optional Attributes Name class( clock_t ), intent(inout) :: this integer, intent(in) :: id procedure, public :: print => clock_print private subroutine clock_print(this) Arguments Type Intent Optional Attributes Name class( clock_t ), intent(inout) :: this","tags":"","loc":"type/clock_t.html"},{"title":"quad_pt_t – Libmbd ","text":"type, public :: quad_pt_t Represents a 1D quadrature point Contents Variables val weight Components Type Visibility Attributes Name Initial real(kind=dp), public :: val real(kind=dp), public :: weight","tags":"","loc":"type/quad_pt_t.html"},{"title":"damping_t – Libmbd ","text":"type, public :: damping_t Represents a damping function. Contents Variables version beta a ts_d ts_sr mayer_scaling r_vdw sigma damping_custom potential_custom Type-Bound Procedures set_params_from_xc Components Type Visibility Attributes Name Initial character(len=20), public :: version real(kind=dp), public :: beta = 0d0 real(kind=dp), public :: a = 6d0 real(kind=dp), public :: ts_d = 20d0 real(kind=dp), public :: ts_sr = 0d0 real(kind=dp), public :: mayer_scaling = 1d0 real(kind=dp), public, allocatable :: r_vdw (:) real(kind=dp), public, allocatable :: sigma (:) real(kind=dp), public, allocatable :: damping_custom (:,:) real(kind=dp), public, allocatable :: potential_custom (:,:,:,:) Type-Bound Procedures procedure, public :: set_params_from_xc => damping_set_params_from_xc private function damping_set_params_from_xc(this, xc, variant) result(exc) Arguments Type Intent Optional Attributes Name class( damping_t ), intent(inout) :: this character(len=*), intent(in) :: xc character(len=*), intent(in) :: variant Return Value type( exception_t )","tags":"","loc":"type/damping_t.html"},{"title":"param_t – Libmbd ","text":"type, public :: param_t Calculation-wide paramters. Contents Variables dipole_cutoff ewald_real_cutoff_scaling ewald_rec_cutoff_scaling k_grid_shift ewald_on zero_negative_eigvals rpa_rescale_eigs rpa_order_max n_freq Components Type Visibility Attributes Name Initial real(kind=dp), public :: dipole_cutoff = 400d0*ang real(kind=dp), public :: ewald_real_cutoff_scaling = 1d0 real(kind=dp), public :: ewald_rec_cutoff_scaling = 1d0 real(kind=dp), public :: k_grid_shift = 0.5d0 logical, public :: ewald_on = .true. logical, public :: zero_negative_eigvals = .false. logical, public :: rpa_rescale_eigs = .false. integer, public :: rpa_order_max = 10 integer, public :: n_freq = 15","tags":"","loc":"type/param_t.html"},{"title":"geom_t – Libmbd ","text":"type, public :: geom_t Represents a molecule or a crystal unit cell. The documented variables should be set before calling the initializer. Contents Variables coords lattice k_grid custom_k_pts parallel_mode get_eigs get_modes do_rpa get_rpa_orders log mpi_comm max_atoms_per_block timer exc freq gamm real_space_cutoff rec_space_cutoff param idx blacs blacs_grid mpi_size mpi_rank Type-Bound Procedures init destroy siz has_exc clock Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: coords (:,:) ( , a.u.) Atomic coordinates. real(kind=dp), public, allocatable :: lattice (:,:) ( , a.u.) Lattice vectors in columns, unallocated if not\n periodic. integer, public, allocatable :: k_grid (:) Number of -points along reciprocal axes. real(kind=dp), public, allocatable :: custom_k_pts (:,:) Custom -point grid. character(len=10), public :: parallel_mode = 'auto' Type of parallelization: atoms : distribute matrices over all MPI tasks using ScaLAPACK,\n solve eigenproblems sequentialy. k_points : parallelize over k-points (each MPI task solves entire\n eigenproblems for its k-points) logical, public :: get_eigs = .false. Whether to keep MBD eigenvalues logical, public :: get_modes = .false. Whether to calculate MBD eigenvectors logical, public :: do_rpa = .false. Whether to calculate MBD energy by frequency integration logical, public :: get_rpa_orders = .false. Whether to calculate RPA orders type(logger_t), public :: log Used for logging integer, public :: mpi_comm = MPI_COMM_WORLD MPI communicator integer, public :: max_atoms_per_block = 6 type( clock_t ), public :: timer type( exception_t ), public :: exc type( quad_pt_t ), public, allocatable :: freq (:) real(kind=dp), public :: gamm = 0d0 real(kind=dp), public :: real_space_cutoff real(kind=dp), public :: rec_space_cutoff type( param_t ), public :: param type( atom_index_t ), public :: idx type(blacs_desc_t), public :: blacs type(blacs_grid_t), public :: blacs_grid integer, public :: mpi_size = -1 integer, public :: mpi_rank = -1 Type-Bound Procedures procedure, public :: init => geom_init private subroutine geom_init(this) Arguments Type Intent Optional Attributes Name class( geom_t ), intent(inout) :: this procedure, public :: destroy => geom_destroy private subroutine geom_destroy(this) Arguments Type Intent Optional Attributes Name class( geom_t ), intent(inout) :: this procedure, public :: siz => geom_siz private function geom_siz(this) result(siz) Arguments Type Intent Optional Attributes Name class( geom_t ), intent(in) :: this Return Value integer procedure, public :: has_exc => geom_has_exc private function geom_has_exc(this) result(has_exc) Arguments Type Intent Optional Attributes Name class( geom_t ), intent(in) :: this Return Value logical procedure, public :: clock => geom_clock private subroutine geom_clock(this, id) Arguments Type Intent Optional Attributes Name class( geom_t ), intent(inout) :: this integer, intent(in) :: id","tags":"","loc":"type/geom_t.html"},{"title":"get_mbd_energy – Libmbd","text":"public function get_mbd_energy(geom, alpha_0, C6, damp, grad) result(res) Get MBD energy. For a nonperiodic system, the method just transforms coefficients\n to frequencies, and performs a single call to get_mbd_hamiltonian_energy . For a periodic system, the method\n integrates the energy over the frist Brillouin zone. Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: C6 (:) type( damping_t ), intent(in) :: damp type( grad_request_t ), intent(in) :: grad Return Value type( result_t ) Contents None","tags":"","loc":"proc/get_mbd_energy.html"},{"title":"get_mbd_scs_energy – Libmbd","text":"public function get_mbd_scs_energy(geom, variant, alpha_0, C6, damp, grad) result(res) Get screened MBD energy. Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom character(len=*), intent(in) :: variant real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: C6 (:) type( damping_t ), intent(in) :: damp type( grad_request_t ), intent(in) :: grad Return Value type( result_t ) Contents None","tags":"","loc":"proc/get_mbd_scs_energy.html"},{"title":"get_ts_energy – Libmbd","text":"public function get_ts_energy(geom, alpha_0, C6, damp, grad) result(res) Get TS energy. Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: C6 (:) type( damping_t ), intent(in) :: damp type( grad_request_t ), intent(in) :: grad Return Value type( result_t ) Contents None","tags":"","loc":"proc/get_ts_energy.html"},{"title":"omega_qho – Libmbd","text":"public function omega_qho(C6, alpha, domega, grad) result(omega) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: C6 (:) real(kind=dp), intent(in) :: alpha (:) type( grad_t ), intent(out), optional :: domega type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (size(C6)) Contents None","tags":"","loc":"proc/omega_qho.html"},{"title":"alpha_dyn_qho – Libmbd","text":"public function alpha_dyn_qho(alpha_0, omega, freq, dalpha, grad) result(alpha) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: omega (:) type( quad_pt_t ), intent(in) :: freq (0:) type( grad_t ), intent(out), allocatable :: dalpha (:) type( grad_request_t ), intent(in) :: grad Return Value real(kind=dp)\n  (size(alpha_0),0:ubound(freq,1)) Contents None","tags":"","loc":"proc/alpha_dyn_qho.html"},{"title":"C6_from_alpha – Libmbd","text":"public function C6_from_alpha(alpha, freq, dC6_dalpha, grad) result(C6) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha (:,0:) type( quad_pt_t ), intent(in) :: freq (0:) real(kind=dp), intent(out), optional allocatable :: dC6_dalpha (:,:) logical, intent(in), optional :: grad Return Value real(kind=dp)\n  (size(alpha,1)) Contents None","tags":"","loc":"proc/c6_from_alpha.html"},{"title":"sigma_selfint – Libmbd","text":"public function sigma_selfint(alpha, dsigma_dalpha, grad) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha (:) real(kind=dp), intent(out), optional allocatable :: dsigma_dalpha (:) logical, intent(in), optional :: grad Return Value real(kind=dp)\n  (size(alpha)) Contents None","tags":"","loc":"proc/sigma_selfint.html"},{"title":"scale_with_ratio – Libmbd","text":"public function scale_with_ratio(x, yp, y, q, dx, grad) result(xp) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(in) :: yp (:) real(kind=dp), intent(in) :: y (:) real(kind=dp), intent(in) :: q type( grad_t ), intent(out), optional :: dx type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (size(x)) Contents None","tags":"","loc":"proc/scale_with_ratio.html"},{"title":"T_bare – Libmbd","text":"public function T_bare(r, dT, grad) result(T) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) type( grad_matrix_re_t ), intent(out), optional :: dT logical, intent(in), optional :: grad Return Value real(kind=dp)\n  (3,3) Contents None","tags":"","loc":"proc/t_bare.html"},{"title":"B_erfc – Libmbd","text":"public function B_erfc(r, gamm, dB, grad) result(B) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r real(kind=dp), intent(in) :: gamm type( grad_scalar_t ), intent(out), optional :: dB type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp) Contents None","tags":"","loc":"proc/b_erfc.html"},{"title":"C_erfc – Libmbd","text":"public function C_erfc(r, gamm, dC, grad) result(C) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r real(kind=dp), intent(in) :: gamm type( grad_scalar_t ), intent(out), optional :: dC type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp) Contents None","tags":"","loc":"proc/c_erfc.html"},{"title":"T_erfc – Libmbd","text":"public function T_erfc(r, gamm, dT, grad) result(T) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) real(kind=dp), intent(in) :: gamm type( grad_matrix_re_t ), intent(out), optional :: dT type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (3,3) Contents None","tags":"","loc":"proc/t_erfc.html"},{"title":"T_erf_coulomb – Libmbd","text":"public function T_erf_coulomb(r, sigma, dT, grad) result(T) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) real(kind=dp), intent(in) :: sigma type( grad_matrix_re_t ), intent(out), optional :: dT type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (3,3) Contents None","tags":"","loc":"proc/t_erf_coulomb.html"},{"title":"dipole_matrix – Libmbd","text":"public interface dipole_matrix Form either a real or a complex dipole matrix. The real-typed version is equivalent to . Contents Module Procedures dipole_matrix_real dipole_matrix_complex Module Procedures private function dipole_matrix_real(geom, damp, ddipmat, grad) result(dipmat) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom type( damping_t ), intent(in) :: damp type( grad_matrix_re_t ), intent(out), optional :: ddipmat type( grad_request_t ), intent(in), optional :: grad Return Value type(matrix_re_t) private function dipole_matrix_complex(geom, damp, ddipmat, grad, q) result(dipmat) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom type( damping_t ), intent(in) :: damp type( grad_matrix_cplx_t ), intent(out), optional :: ddipmat type( grad_request_t ), intent(in), optional :: grad real(kind=dp), intent(in) :: q (3) Return Value type(matrix_cplx_t)","tags":"","loc":"interface/dipole_matrix.html"},{"title":"damping_fermi – Libmbd","text":"public function damping_fermi(r, s_vdw, d, df, grad) result(f) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) real(kind=dp), intent(in) :: s_vdw real(kind=dp), intent(in) :: d type( grad_scalar_t ), intent(out), optional :: df type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp) Contents None","tags":"","loc":"proc/damping_fermi.html"},{"title":"run_scs – Libmbd","text":"public function run_scs(geom, alpha, damp, dalpha_scs, grad) result(alpha_scs) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha (:) type( damping_t ), intent(in) :: damp type( grad_t ), intent(out) :: dalpha_scs (:) type( grad_request_t ), intent(in) :: grad Return Value real(kind=dp)\n  (size(alpha)) Contents None","tags":"","loc":"proc/run_scs.html"},{"title":"get_mbd_hamiltonian_energy – Libmbd","text":"public interface get_mbd_hamiltonian_energy Form and solve either a real or a complex MBD Hamiltonian. The real-typed version is equivalent to . Contents Module Procedures get_mbd_hamiltonian_energy_real get_mbd_hamiltonian_energy_complex Module Procedures private function get_mbd_hamiltonian_energy_real(geom, alpha_0, omega, damp, grad) result(res) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: omega (:) type( damping_t ), intent(in) :: damp type( grad_request_t ), intent(in) :: grad Return Value type( result_t ) private function get_mbd_hamiltonian_energy_complex(geom, alpha_0, omega, damp, grad, q) result(res) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: omega (:) type( damping_t ), intent(in) :: damp type( grad_request_t ), intent(in) :: grad real(kind=dp), intent(in) :: q (3) Return Value type( result_t )","tags":"","loc":"interface/get_mbd_hamiltonian_energy.html"},{"title":"mbd – Libmbd","text":"High-level Fortran API. Uses mbd_constants mbd_damping mbd_formulas mbd_geom mbd_gradients mbd_methods mbd_ts mbd_utils mbd_vdw_param Contents Derived Types mbd_input_t mbd_calc_t Derived Types type, public :: mbd_input_t Contains user input to an MBD calculation. Components Type Visibility Attributes Name Initial character(len=30), public :: method = 'mbd-rsscs' VdW method to use to calculate energy and gradients. mbd-rsscs : The MBD@rsSCS method. mbd-nl : The MBD-NL method. ts : The TS method. mbd : Generic MBD method (without any screening). integer, public :: comm = -1 MPI communicator. Only used when compiled with MPI. Leave as is to use the\n MPI_COMM_WORLD communicator. integer, public :: max_atoms_per_block = 6 Number of atoms per block in a BLACS grid. integer, public :: log_level = MBD_LOG_LVL_INFO Level of printing procedure(printer_i), public, nopass, pointer :: printer => null() If assigned, will be used for logging logical, public :: calculate_forces = .true. Whether to calculate forces. logical, public :: calculate_vdw_params_gradients = .false. Whether to calculate gradients of energy w.r.t. vdW parameters logical, public :: calculate_spectrum = .false. Whether to keep MBD eigenvalues. logical, public :: do_rpa = .false. Whether to evalulate the MBD energy as an RPA integral over frequency. logical, public :: rpa_orders = .false. Whether to calculate individual RPA orders logical, public :: rpa_rescale_eigs = .false. Whether to rescale RPA eigenvalues as in 10.1021/acs.jctc.6b00925. integer, public :: n_omega_grid = 15 Number of imaginary frequency grid points. real(kind=dp), public :: k_grid_shift = 0.5d0 Off- shift of the -point grid in units of\n inter- -point distance. logical, public :: zero_negative_eigvals = .false. Whether to zero out negative eigenvalues. character(len=20), public :: xc = '' XC functional for automatic setting of damping parameters. real(kind=dp), public :: ts_d = 20d0 TS damping parameter . real(kind=dp), public :: ts_sr = -1 Custom TS damping parameter . Leave as is to use a value based on the XC functional. real(kind=dp), public :: mbd_a = 6d0 MBD damping parameter . real(kind=dp), public :: mbd_beta = -1 Custom MBD damping parameter . Leave as is to use a value based on the XC functional. character(len=10), public :: vdw_params_kind = 'ts' Which free-atom reference vdW parameters to use for scaling. ts : Values from original TS method. tssurf : Values from the TS approach. character(len=3), public, allocatable :: atom_types (:) ( ) Atom types used for picking free-atom reference values. real(kind=dp), public, allocatable :: free_values (:,:) ( , a.u.) Custom free-atom vdW paramters to use for\n scaling. Columns contain static polarizabilities, C6 coefficients, and vdW\n radii. real(kind=dp), public, allocatable :: coords (:,:) ( , a.u.) Atomic coordinates. real(kind=dp), public, allocatable :: lattice_vectors (:,:) ( , a.u.) Lattice vectors in columns, unallocated if not\n periodic. integer, public :: k_grid (3) = [-1, -1, -1] Number of -points along reciprocal axes. character(len=10), public :: parallel_mode = 'auto' Parallelization scheme. auto : Pick based on system system size and number of -points. kpoints : Parallelize over -points. atoms : Parallelize over atom pairs. type, public :: mbd_calc_t Represents an MBD calculation. Type-Bound Procedures procedure, public :: init => mbd_calc_init procedure, public :: destroy => mbd_calc_destroy procedure, public :: switch_forces => mbd_calc_switch_forces procedure, public :: update_coords => mbd_calc_update_coords procedure, public :: update_lattice_vectors => mbd_calc_update_lattice_vectors procedure, public :: update_vdw_params_custom => mbd_calc_update_vdw_params_custom procedure, public :: update_vdw_params_from_ratios => mbd_calc_update_vdw_params_from_ratios procedure, public :: update_vdw_params_nl => mbd_calc_update_vdw_params_nl procedure, public :: evaluate_vdw_method => mbd_calc_evaluate_vdw_method procedure, public :: get_gradients => mbd_calc_get_gradients procedure, public :: get_vdw_params_ratios_gradients => mbd_calc_get_vdw_params_ratios_gradients procedure, public :: get_lattice_derivs => mbd_calc_get_lattice_derivs procedure, public :: get_lattice_stress => mbd_calc_get_lattice_stress procedure, public :: get_spectrum_modes => mbd_calc_get_spectrum_modes procedure, public :: get_rpa_orders => mbd_calc_get_rpa_orders procedure, public :: get_exception => mbd_calc_get_exception","tags":"","loc":"module/mbd.html"},{"title":"mbd_constants – Libmbd","text":"Constants used throughout. Contents Variables ang MBD_EXC_NEG_EIGVALS MBD_EXC_NEG_POL MBD_EXC_LINALG MBD_EXC_UNIMPL MBD_EXC_DAMPING MBD_EXC_INPUT Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: ang = 1.8897259886d0 Value of angstrom in atomic units integer, public, parameter :: MBD_EXC_NEG_EIGVALS = 1 Negative eigenvalue exception integer, public, parameter :: MBD_EXC_NEG_POL = 2 Negative polarizability exception integer, public, parameter :: MBD_EXC_LINALG = 3 Exception in LAPACK or ScaLAPACK integer, public, parameter :: MBD_EXC_UNIMPL = 4 Functionality is not implemented integer, public, parameter :: MBD_EXC_DAMPING = 5 Damping-function exception integer, public, parameter :: MBD_EXC_INPUT = 6 Invalid input","tags":"","loc":"module/mbd_constants.html"},{"title":"mbd_gradients – Libmbd","text":"Derivatives. Uses mbd_constants Contents Derived Types grad_t grad_matrix_re_t grad_matrix_cplx_t grad_scalar_t grad_request_t Derived Types type, public :: grad_t Derivatives with respect to various quantities Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dcoords (:,:) real(kind=dp), public, allocatable :: dlattice (:,:) real(kind=dp), public, allocatable :: dalpha (:) real(kind=dp), public, allocatable :: dalpha_dyn (:,:) real(kind=dp), public, allocatable :: dC6 (:) real(kind=dp), public, allocatable :: dq (:) real(kind=dp), public, allocatable :: dr_vdw (:) real(kind=dp), public, allocatable :: domega (:) real(kind=dp), public, allocatable :: dV (:) real(kind=dp), public, allocatable :: dV_free (:) real(kind=dp), public, allocatable :: dX_free (:) type, public :: grad_matrix_re_t Derivatives of a real dipole matrix with respect to various quantities Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dr (:,:,:) real(kind=dp), public, allocatable :: dlattice (:,:,:,:) real(kind=dp), public, allocatable :: dvdw (:,:) real(kind=dp), public, allocatable :: dsigma (:,:) real(kind=dp), public, allocatable :: dgamma (:,:) type, public :: grad_matrix_cplx_t Derivatives of a compelx dipole matrix with respect to various quantities Components Type Visibility Attributes Name Initial complex(kind=dp), public, allocatable :: dr (:,:,:) complex(kind=dp), public, allocatable :: dlattice (:,:,:,:) complex(kind=dp), public, allocatable :: dq (:,:,:) complex(kind=dp), public, allocatable :: dvdw (:,:) complex(kind=dp), public, allocatable :: dsigma (:,:) complex(kind=dp), public, allocatable :: dgamma (:,:) type, public :: grad_scalar_t Derivatives of a scalar with respect to various quantities Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dr (:) real(kind=dp), public, allocatable :: dr_1 real(kind=dp), public, allocatable :: dk_1 real(kind=dp), public, allocatable :: dvdw real(kind=dp), public, allocatable :: dgamma real(kind=dp), public, allocatable :: dC6 real(kind=dp), public, allocatable :: dC6i real(kind=dp), public, allocatable :: dC6j real(kind=dp), public, allocatable :: da0i real(kind=dp), public, allocatable :: da0j type, public :: grad_request_t Used to request derivatives with respect to function arguments Components Type Visibility Attributes Name Initial logical, public :: dcoords = .false. logical, public :: dalpha = .false. logical, public :: dalpha_dyn = .false. logical, public :: dC6 = .false. logical, public :: dr_vdw = .false. logical, public :: domega = .false. logical, public :: dsigma = .false. logical, public :: dgamma = .false. logical, public :: dq = .false. logical, public :: dlattice = .false. logical, public :: dV = .false. logical, public :: dV_free = .false. logical, public :: dX_free = .false. Type-Bound Procedures procedure, public :: any => grad_request_any","tags":"","loc":"module/mbd_gradients.html"},{"title":"mbd_elsi – Libmbd","text":"Uses elsi mbd_constants mbd_blacs mbd_utils Contents None","tags":"","loc":"module/mbd_elsi.html"},{"title":"mbd_methods – Libmbd","text":"Obtaining MBD energies. Uses mbd_constants mbd_damping mbd_formulas mbd_geom mbd_gradients mbd_hamiltonian mbd_lapack mbd_rpa mbd_scs mbd_utils mbd_blacs mbd_mpi Contents Functions get_mbd_energy get_mbd_scs_energy Functions public function get_mbd_energy (geom, alpha_0, C6, damp, grad) result(res) Get MBD energy. For a nonperiodic system, the method just transforms coefficients\n to frequencies, and performs a single call to get_mbd_hamiltonian_energy . For a periodic system, the method\n integrates the energy over the frist Brillouin zone. Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: C6 (:) type( damping_t ), intent(in) :: damp type( grad_request_t ), intent(in) :: grad Return Value type( result_t ) public function get_mbd_scs_energy (geom, variant, alpha_0, C6, damp, grad) result(res) Get screened MBD energy. Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom character(len=*), intent(in) :: variant real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: C6 (:) type( damping_t ), intent(in) :: damp type( grad_request_t ), intent(in) :: grad Return Value type( result_t )","tags":"","loc":"module/mbd_methods.html"},{"title":"mbd_ts – Libmbd","text":"Obtaining TS energies. Uses mbd_constants mbd_utils mbd_damping mbd_geom mbd_gradients mbd_lapack mbd_mpi Contents Functions get_ts_energy Functions public function get_ts_energy (geom, alpha_0, C6, damp, grad) result(res) Get TS energy. Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: C6 (:) type( damping_t ), intent(in) :: damp type( grad_request_t ), intent(in) :: grad Return Value type( result_t )","tags":"","loc":"module/mbd_ts.html"},{"title":"mbd_formulas – Libmbd","text":"Common formulas used at multiple places. Uses mbd_constants mbd_gradients mbd_utils Contents Functions omega_qho alpha_dyn_qho C6_from_alpha sigma_selfint scale_with_ratio Functions public function omega_qho (C6, alpha, domega, grad) result(omega) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: C6 (:) real(kind=dp), intent(in) :: alpha (:) type( grad_t ), intent(out), optional :: domega type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (size(C6)) public function alpha_dyn_qho (alpha_0, omega, freq, dalpha, grad) result(alpha) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: omega (:) type( quad_pt_t ), intent(in) :: freq (0:) type( grad_t ), intent(out), allocatable :: dalpha (:) type( grad_request_t ), intent(in) :: grad Return Value real(kind=dp)\n  (size(alpha_0),0:ubound(freq,1)) public function C6_from_alpha (alpha, freq, dC6_dalpha, grad) result(C6) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha (:,0:) type( quad_pt_t ), intent(in) :: freq (0:) real(kind=dp), intent(out), optional allocatable :: dC6_dalpha (:,:) logical, intent(in), optional :: grad Return Value real(kind=dp)\n  (size(alpha,1)) public function sigma_selfint (alpha, dsigma_dalpha, grad) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha (:) real(kind=dp), intent(out), optional allocatable :: dsigma_dalpha (:) logical, intent(in), optional :: grad Return Value real(kind=dp)\n  (size(alpha)) public function scale_with_ratio (x, yp, y, q, dx, grad) result(xp) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(in) :: yp (:) real(kind=dp), intent(in) :: y (:) real(kind=dp), intent(in) :: q type( grad_t ), intent(out), optional :: dx type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (size(x))","tags":"","loc":"module/mbd_formulas.html"},{"title":"mbd_dipole – Libmbd","text":"Construction of dipole tensors and dipole matrices. Uses mbd_constants mbd_matrix mbd_geom mbd_damping mbd_gradients mbd_lapack mbd_linalg mbd_utils Contents Interfaces dipole_matrix Functions T_bare B_erfc C_erfc T_erfc T_erf_coulomb Interfaces public interface dipole_matrix Form either a real or a complex dipole matrix. The real-typed version is equivalent to . private function dipole_matrix_real(geom, damp, ddipmat, grad) result(dipmat) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom type( damping_t ), intent(in) :: damp type( grad_matrix_re_t ), intent(out), optional :: ddipmat type( grad_request_t ), intent(in), optional :: grad Return Value type(matrix_re_t) private function dipole_matrix_complex(geom, damp, ddipmat, grad, q) result(dipmat) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom type( damping_t ), intent(in) :: damp type( grad_matrix_cplx_t ), intent(out), optional :: ddipmat type( grad_request_t ), intent(in), optional :: grad real(kind=dp), intent(in) :: q (3) Return Value type(matrix_cplx_t) Functions public function T_bare (r, dT, grad) result(T) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) type( grad_matrix_re_t ), intent(out), optional :: dT logical, intent(in), optional :: grad Return Value real(kind=dp)\n  (3,3) public function B_erfc (r, gamm, dB, grad) result(B) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r real(kind=dp), intent(in) :: gamm type( grad_scalar_t ), intent(out), optional :: dB type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp) public function C_erfc (r, gamm, dC, grad) result(C) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r real(kind=dp), intent(in) :: gamm type( grad_scalar_t ), intent(out), optional :: dC type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp) public function T_erfc (r, gamm, dT, grad) result(T) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) real(kind=dp), intent(in) :: gamm type( grad_matrix_re_t ), intent(out), optional :: dT type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (3,3) public function T_erf_coulomb (r, sigma, dT, grad) result(T) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) real(kind=dp), intent(in) :: sigma type( grad_matrix_re_t ), intent(out), optional :: dT type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (3,3)","tags":"","loc":"module/mbd_dipole.html"},{"title":"mbd_utils – Libmbd","text":"Utility types, interfaces, and procedures. Uses mbd_constants mbd_gradients mbd_mpi Contents Derived Types exception_t result_t atom_index_t clock_t quad_pt_t Derived Types type, public :: exception_t Represents an exception. Components Type Visibility Attributes Name Initial integer, public :: code = 0 character(len=50), public :: origin = '(unknown)' character(len=150), public :: msg = '' type, public :: result_t Stores results from an MBD calculation Components Type Visibility Attributes Name Initial real(kind=dp), public :: energy type( grad_t ), public :: dE real(kind=dp), public, allocatable :: mode_eigs (:) real(kind=dp), public, allocatable :: modes (:,:) real(kind=dp), public, allocatable :: rpa_orders (:) real(kind=dp), public, allocatable :: mode_eigs_k (:,:) complex(kind=dp), public, allocatable :: modes_k (:,:,:) complex(kind=dp), public, allocatable :: modes_k_single (:,:) real(kind=dp), public, allocatable :: rpa_orders_k (:,:) type, public :: atom_index_t Maps from atom indexes to positions in matrices. Components Type Visibility Attributes Name Initial integer, public, allocatable :: i_atom (:) integer, public, allocatable :: j_atom (:) integer, public :: n_atoms logical, public :: parallel type, public :: clock_t Used for measuring performance. Components Type Visibility Attributes Name Initial logical, public :: active = .true. integer(kind=i8), public, allocatable :: timestamps (:) integer(kind=i8), public, allocatable :: counts (:) Type-Bound Procedures procedure, public :: init => clock_init procedure, public :: clock => clock_clock procedure, public :: print => clock_print type, public :: quad_pt_t Represents a 1D quadrature point Components Type Visibility Attributes Name Initial real(kind=dp), public :: val real(kind=dp), public :: weight","tags":"","loc":"module/mbd_utils.html"},{"title":"mbd_damping – Libmbd","text":"Damping functions. Uses mbd_constants mbd_gradients mbd_utils Contents Derived Types damping_t Functions damping_fermi Derived Types type, public :: damping_t Represents a damping function. Components Type Visibility Attributes Name Initial character(len=20), public :: version real(kind=dp), public :: beta = 0d0 real(kind=dp), public :: a = 6d0 real(kind=dp), public :: ts_d = 20d0 real(kind=dp), public :: ts_sr = 0d0 real(kind=dp), public :: mayer_scaling = 1d0 real(kind=dp), public, allocatable :: r_vdw (:) real(kind=dp), public, allocatable :: sigma (:) real(kind=dp), public, allocatable :: damping_custom (:,:) real(kind=dp), public, allocatable :: potential_custom (:,:,:,:) Type-Bound Procedures procedure, public :: set_params_from_xc => damping_set_params_from_xc Functions public function damping_fermi (r, s_vdw, d, df, grad) result(f) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) real(kind=dp), intent(in) :: s_vdw real(kind=dp), intent(in) :: d type( grad_scalar_t ), intent(out), optional :: df type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)","tags":"","loc":"module/mbd_damping.html"},{"title":"mbd_scs – Libmbd","text":"Performing self-consistent screening. Uses mbd_constants mbd_damping mbd_dipole mbd_formulas mbd_geom mbd_gradients mbd_matrix mbd_utils Contents Functions run_scs Functions public function run_scs (geom, alpha, damp, dalpha_scs, grad) result(alpha_scs) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha (:) type( damping_t ), intent(in) :: damp type( grad_t ), intent(out) :: dalpha_scs (:) type( grad_request_t ), intent(in) :: grad Return Value real(kind=dp)\n  (size(alpha))","tags":"","loc":"module/mbd_scs.html"},{"title":"mbd_geom – Libmbd","text":"Representing a molecule or a crystal unit cell. Uses mbd_constants mbd_formulas mbd_gradients mbd_lapack mbd_utils mbd_vdw_param mbd_blacs mbd_mpi Contents Derived Types param_t geom_t Derived Types type, public :: param_t Calculation-wide paramters. Components Type Visibility Attributes Name Initial real(kind=dp), public :: dipole_cutoff = 400d0*ang real(kind=dp), public :: ewald_real_cutoff_scaling = 1d0 real(kind=dp), public :: ewald_rec_cutoff_scaling = 1d0 real(kind=dp), public :: k_grid_shift = 0.5d0 logical, public :: ewald_on = .true. logical, public :: zero_negative_eigvals = .false. logical, public :: rpa_rescale_eigs = .false. integer, public :: rpa_order_max = 10 integer, public :: n_freq = 15 type, public :: geom_t Represents a molecule or a crystal unit cell. The documented variables should be set before calling the initializer. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: coords (:,:) ( , a.u.) Atomic coordinates. real(kind=dp), public, allocatable :: lattice (:,:) ( , a.u.) Lattice vectors in columns, unallocated if not\n periodic. integer, public, allocatable :: k_grid (:) Number of -points along reciprocal axes. real(kind=dp), public, allocatable :: custom_k_pts (:,:) Custom -point grid. character(len=10), public :: parallel_mode = 'auto' Type of parallelization: atoms : distribute matrices over all MPI tasks using ScaLAPACK,\n solve eigenproblems sequentialy. k_points : parallelize over k-points (each MPI task solves entire\n eigenproblems for its k-points) logical, public :: get_eigs = .false. Whether to keep MBD eigenvalues logical, public :: get_modes = .false. Whether to calculate MBD eigenvectors logical, public :: do_rpa = .false. Whether to calculate MBD energy by frequency integration logical, public :: get_rpa_orders = .false. Whether to calculate RPA orders type(logger_t), public :: log Used for logging integer, public :: mpi_comm = MPI_COMM_WORLD MPI communicator integer, public :: max_atoms_per_block = 6 type( clock_t ), public :: timer type( exception_t ), public :: exc type( quad_pt_t ), public, allocatable :: freq (:) real(kind=dp), public :: gamm = 0d0 real(kind=dp), public :: real_space_cutoff real(kind=dp), public :: rec_space_cutoff type( param_t ), public :: param type( atom_index_t ), public :: idx type(blacs_desc_t), public :: blacs type(blacs_grid_t), public :: blacs_grid integer, public :: mpi_size = -1 integer, public :: mpi_rank = -1 Type-Bound Procedures procedure, public :: init => geom_init procedure, public :: destroy => geom_destroy procedure, public :: siz => geom_siz procedure, public :: has_exc => geom_has_exc procedure, public :: clock => geom_clock","tags":"","loc":"module/mbd_geom.html"},{"title":"mbd_hamiltonian – Libmbd","text":"Forming and solving MBD Hamiltonian. Uses mbd_constants mbd_damping mbd_dipole mbd_geom mbd_gradients mbd_matrix mbd_utils Contents Interfaces get_mbd_hamiltonian_energy Interfaces public interface get_mbd_hamiltonian_energy Form and solve either a real or a complex MBD Hamiltonian. The real-typed version is equivalent to . private function get_mbd_hamiltonian_energy_real(geom, alpha_0, omega, damp, grad) result(res) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: omega (:) type( damping_t ), intent(in) :: damp type( grad_request_t ), intent(in) :: grad Return Value type( result_t ) private function get_mbd_hamiltonian_energy_complex(geom, alpha_0, omega, damp, grad, q) result(res) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: omega (:) type( damping_t ), intent(in) :: damp type( grad_request_t ), intent(in) :: grad real(kind=dp), intent(in) :: q (3) Return Value type( result_t )","tags":"","loc":"module/mbd_hamiltonian.html"}]}